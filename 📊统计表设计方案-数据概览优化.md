# 📊 统计表设计方案 - 数据概览优化

> 创建时间：2025-08-15
> 目的：为数据概览页面创建预计算统计表，避免实时计算

---

## 一、🎯 问题分析

### 当前问题：
1. **所有统计数据都是实时计算** - 每次访问都要执行复杂查询
2. **性能开销大** - 需要扫描所有订单和销售数据
3. **响应速度慢** - 数据量增长后会明显变慢
4. **服务器压力大** - 频繁的聚合计算消耗资源

### 解决方案：
创建专门的统计表，定期更新预计算的统计数据。

---

## 二、📊 统计表设计

### 1️⃣ overview_stats表 - 概览统计表（新建）
```sql
CREATE TABLE overview_stats (
  id SERIAL PRIMARY KEY,
  
  -- 统计时间范围
  stat_period VARCHAR(20) NOT NULL,               -- all/today/week/month/year/custom
  start_date DATE,                                -- 统计开始日期
  end_date DATE,                                  -- 统计结束日期
  
  -- 订单统计
  total_orders INTEGER DEFAULT 0,                 -- 总订单数
  pending_payment_orders INTEGER DEFAULT 0,       -- 待付款确认订单数
  pending_config_orders INTEGER DEFAULT 0,        -- 待配置确认订单数
  confirmed_config_orders INTEGER DEFAULT 0,      -- 已配置确认订单数
  rejected_orders INTEGER DEFAULT 0,              -- 已拒绝订单数
  
  -- 财务统计
  total_amount DECIMAL(10,2) DEFAULT 0,          -- 总收入
  commission_amount DECIMAL(10,2) DEFAULT 0,     -- 销售返佣金额
  pending_commission_amount DECIMAL(10,2) DEFAULT 0, -- 待返佣金金额
  paid_commission_amount DECIMAL(10,2) DEFAULT 0,    -- 已付佣金金额
  
  -- 销售层级统计
  primary_sales_count INTEGER DEFAULT 0,          -- 一级销售数量
  primary_sales_amount DECIMAL(10,2) DEFAULT 0,   -- 一级销售业绩
  linked_secondary_sales_count INTEGER DEFAULT 0, -- 二级销售数量
  linked_secondary_sales_amount DECIMAL(10,2) DEFAULT 0, -- 二级销售业绩
  independent_sales_count INTEGER DEFAULT 0,      -- 独立销售数量
  independent_sales_amount DECIMAL(10,2) DEFAULT 0, -- 独立销售业绩
  
  -- 订单时长分类统计
  free_trial_orders INTEGER DEFAULT 0,            -- 7天免费订单数
  free_trial_percentage DECIMAL(5,2) DEFAULT 0,   -- 7天免费订单占比
  one_month_orders INTEGER DEFAULT 0,             -- 1个月订单数
  one_month_percentage DECIMAL(5,2) DEFAULT 0,    -- 1个月订单占比
  three_month_orders INTEGER DEFAULT 0,           -- 3个月订单数
  three_month_percentage DECIMAL(5,2) DEFAULT 0,  -- 3个月订单占比
  six_month_orders INTEGER DEFAULT 0,             -- 6个月订单数
  six_month_percentage DECIMAL(5,2) DEFAULT 0,    -- 6个月订单占比
  yearly_orders INTEGER DEFAULT 0,                -- 年费订单数
  yearly_percentage DECIMAL(5,2) DEFAULT 0,       -- 年费订单占比
  
  -- 其他统计
  new_customers_count INTEGER DEFAULT 0,          -- 新客户数量
  active_customers_count INTEGER DEFAULT 0,       -- 活跃客户数量
  
  -- 元数据
  last_calculated_at TIMESTAMP,                   -- 最后计算时间
  calculation_duration_ms INTEGER,                -- 计算耗时（毫秒）
  
  -- 预留字段
  extra_stats_json JSONB,                        -- 额外统计数据（JSON格式）
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE UNIQUE INDEX idx_stats_period ON overview_stats(stat_period, start_date, end_date);
CREATE INDEX idx_stats_calculated ON overview_stats(last_calculated_at);
```

### 2️⃣ sales_ranking表 - 销售排行榜表（新建）
```sql
CREATE TABLE sales_ranking (
  id SERIAL PRIMARY KEY,
  
  -- 排行榜信息
  ranking_period VARCHAR(20) NOT NULL,            -- all/today/week/month/year
  rank_position INTEGER NOT NULL,                 -- 排名（1-N）
  
  -- 销售信息（冗余存储）
  sales_id INTEGER,                               -- 销售ID
  sales_code VARCHAR(50),                         -- 销售代码
  sales_wechat VARCHAR(100),                      -- 销售微信
  sales_name VARCHAR(100),                        -- 销售名称
  sales_type VARCHAR(20),                         -- primary/secondary/independent
  
  -- 上级信息（如果是二级销售）
  primary_sales_id INTEGER,                       -- 一级销售ID
  primary_sales_wechat VARCHAR(100),              -- 一级销售微信
  primary_sales_name VARCHAR(100),                -- 一级销售名称
  
  -- 业绩数据
  total_orders INTEGER DEFAULT 0,                 -- 总订单数
  paid_orders INTEGER DEFAULT 0,                  -- 已付款订单数
  total_amount DECIMAL(10,2) DEFAULT 0,           -- 总销售额
  commission_amount DECIMAL(10,2) DEFAULT 0,      -- 总佣金
  sales_percentage DECIMAL(5,2) DEFAULT 0,        -- 占总销售额比例
  
  -- 时间范围
  start_date DATE,                                -- 统计开始日期
  end_date DATE,                                  -- 统计结束日期
  
  -- 元数据
  last_calculated_at TIMESTAMP,                   -- 最后计算时间
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_ranking_period ON sales_ranking(ranking_period, rank_position);
CREATE INDEX idx_ranking_sales ON sales_ranking(sales_id);
```

### 3️⃣ daily_stats表 - 每日统计快照表（新建）
```sql
CREATE TABLE daily_stats (
  id SERIAL PRIMARY KEY,
  stat_date DATE UNIQUE NOT NULL,                 -- 统计日期
  
  -- 当日新增
  new_orders INTEGER DEFAULT 0,                   -- 新增订单数
  new_customers INTEGER DEFAULT 0,                -- 新增客户数
  new_sales INTEGER DEFAULT 0,                    -- 新增销售数
  daily_revenue DECIMAL(10,2) DEFAULT 0,          -- 当日收入
  daily_commission DECIMAL(10,2) DEFAULT 0,       -- 当日佣金
  
  -- 累计数据（截至当日）
  total_orders_cumulative INTEGER DEFAULT 0,      -- 累计订单数
  total_customers_cumulative INTEGER DEFAULT 0,   -- 累计客户数
  total_sales_cumulative INTEGER DEFAULT 0,       -- 累计销售数
  total_revenue_cumulative DECIMAL(10,2) DEFAULT 0, -- 累计收入
  
  -- 活跃数据
  active_subscriptions INTEGER DEFAULT 0,         -- 活跃订阅数
  expiring_soon_count INTEGER DEFAULT 0,          -- 即将到期数（7天内）
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_daily_stats_date ON daily_stats(stat_date);
```

---

## 三、🔄 数据更新策略

### 1. 实时更新触发器（适用于小数据量）
```sql
-- 订单创建/更新时更新统计
CREATE OR REPLACE FUNCTION update_stats_on_order_change()
RETURNS TRIGGER AS $$
BEGIN
  -- 更新overview_stats表的all时间段
  UPDATE overview_stats 
  SET 
    total_orders = (SELECT COUNT(*) FROM orders),
    total_amount = (SELECT SUM(amount) FROM orders WHERE status = 'confirmed_config'),
    last_calculated_at = NOW()
  WHERE stat_period = 'all';
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_order_stats_update
AFTER INSERT OR UPDATE ON orders
FOR EACH ROW EXECUTE FUNCTION update_stats_on_order_change();
```

### 2. 定时任务更新（推荐，适用于大数据量）
```sql
-- 创建存储过程，定期执行
CREATE OR REPLACE FUNCTION refresh_overview_stats()
RETURNS void AS $$
DECLARE
  start_time TIMESTAMP;
  duration_ms INTEGER;
BEGIN
  start_time := clock_timestamp();
  
  -- 删除旧的all统计
  DELETE FROM overview_stats WHERE stat_period = 'all';
  
  -- 插入新的统计数据
  INSERT INTO overview_stats (
    stat_period,
    total_orders,
    pending_payment_orders,
    pending_config_orders,
    confirmed_config_orders,
    total_amount,
    commission_amount,
    pending_commission_amount,
    -- ... 其他字段
    last_calculated_at
  )
  SELECT 
    'all' as stat_period,
    COUNT(*) as total_orders,
    COUNT(*) FILTER (WHERE status = 'pending_payment') as pending_payment_orders,
    COUNT(*) FILTER (WHERE status = 'pending_config') as pending_config_orders,
    COUNT(*) FILTER (WHERE status = 'confirmed_config') as confirmed_config_orders,
    COALESCE(SUM(amount), 0) as total_amount,
    COALESCE(SUM(commission_amount), 0) as commission_amount,
    COALESCE(SUM(commission_amount) FILTER (WHERE status != 'paid'), 0) as pending_commission_amount,
    -- ... 其他统计
    NOW() as last_calculated_at
  FROM orders;
  
  -- 计算耗时
  duration_ms := EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time));
  
  UPDATE overview_stats 
  SET calculation_duration_ms = duration_ms 
  WHERE stat_period = 'all';
  
END;
$$ LANGUAGE plpgsql;

-- 设置定时任务（每小时执行一次）
-- 注意：Supabase需要使用pg_cron扩展
SELECT cron.schedule('refresh-stats', '0 * * * *', 'SELECT refresh_overview_stats();');
```

### 3. 混合策略（最优）
- **关键指标实时更新**：待付款订单数、待配置订单数
- **统计数据定期更新**：销售排行、订单分类统计（每小时）
- **历史数据每日更新**：daily_stats表（每天凌晨）

---

## 四、📱 前端代码改造

### 修改getStats API调用：
```javascript
// 原来：每次都计算
const getStats = async (params) => {
  // 复杂的实时计算逻辑
}

// 改为：直接读取预计算数据
const getStats = async (params) => {
  const { timeRange = 'all' } = params;
  
  // 直接查询overview_stats表
  const { data, error } = await supabase
    .from('overview_stats')
    .select('*')
    .eq('stat_period', timeRange)
    .single();
    
  return data;
}

// 提供手动刷新按钮
const refreshStats = async () => {
  // 调用refresh_overview_stats存储过程
  const { data, error } = await supabase
    .rpc('refresh_overview_stats');
}
```

---

## 五、✅ 实施步骤

### 第1步：创建统计表（不影响现有功能）
```sql
-- 执行上述CREATE TABLE语句
-- 这些是新表，不影响现有系统
```

### 第2步：初始化统计数据
```sql
-- 执行一次完整的统计计算
SELECT refresh_overview_stats();
```

### 第3步：设置定时任务
```sql
-- 在Supabase控制台启用pg_cron扩展
-- 设置定时刷新任务
```

### 第4步：逐步切换前端
1. 先创建新的API读取统计表
2. 在测试页面验证数据准确性
3. 逐步替换生产环境的API调用

---

## 六、🎯 预期效果

### 性能提升：
- **查询速度**：从3-5秒降低到100ms以内
- **服务器负载**：降低90%以上
- **用户体验**：页面秒开，无需等待

### 数据准确性：
- **实时性**：关键指标实时，统计数据延迟不超过1小时
- **一致性**：所有用户看到相同的统计数据
- **可追溯**：记录每次计算的时间和耗时

### 扩展性：
- **支持更多统计维度**：通过extra_stats_json字段
- **支持自定义时间范围**：custom时间段
- **支持历史数据对比**：daily_stats表

---

## 七、🔍 注意事项

1. **Supabase限制**：
   - 需要启用pg_cron扩展（可能需要付费计划）
   - 或使用外部定时任务服务（如Vercel Cron Jobs）

2. **数据一致性**：
   - 设置合理的更新频率
   - 关键数据保持实时更新

3. **备用方案**：
   - 保留原有实时计算逻辑作为备用
   - 提供手动刷新功能

这个方案能够大幅提升数据概览页面的性能，你觉得如何？