# 📋 知行财库系统完整优化方案 - 测试环境版

> ⚠️ **重要说明**：所有优化方案仅在测试环境执行，需要您明确同意后才能上线
> 创建时间：2024-12-19
> 版本：v1.0
> 状态：测试环境方案

---

## 一、订单管理页面优化（AdminOrders）

### 1.1 现状问题分析
- **加载时间**: 2-4秒
- **数据量**: 291个订单，每个订单需JOIN 4个表
- **性能瓶颈**:
  - 每次查询JOIN orders、primary_sales、secondary_sales、customers表
  - 无分页优化，一次加载所有数据
  - 缺少索引导致全表扫描
  - 状态更新需要刷新整个页面

### 1.2 数据库优化方案

#### 1.2.1 预留字段（为用户注册功能准备）
```sql
-- orders表预留字段
ALTER TABLE orders ADD COLUMN IF NOT EXISTS user_id INTEGER;  -- 用户账号ID
ALTER TABLE orders ADD COLUMN IF NOT EXISTS customer_became_sales BOOLEAN DEFAULT FALSE;  -- 客户是否转销售
ALTER TABLE orders ADD COLUMN IF NOT EXISTS sales_conversion_date TIMESTAMP;  -- 转化时间
ALTER TABLE orders ADD COLUMN IF NOT EXISTS link_type VARCHAR(20);  -- 链接类型: purchase/recruit
ALTER TABLE orders ADD COLUMN IF NOT EXISTS parent_sales_type VARCHAR(20);  -- 上级销售类型
ALTER TABLE orders ADD COLUMN IF NOT EXISTS commission_rate_snapshot DECIMAL(5,2);  -- 返佣率快照
ALTER TABLE orders ADD COLUMN IF NOT EXISTS is_first_order BOOLEAN DEFAULT FALSE;  -- 是否首单
ALTER TABLE orders ADD COLUMN IF NOT EXISTS referral_source VARCHAR(50);  -- 推荐来源
ALTER TABLE orders ADD COLUMN IF NOT EXISTS auto_renewal BOOLEAN DEFAULT FALSE;  -- 是否自动续费
ALTER TABLE orders ADD COLUMN IF NOT EXISTS renewal_from_order_id INTEGER;  -- 续费来源订单
```

#### 1.2.2 创建高性能索引
```sql
-- 核心索引
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_status ON orders(status) WHERE status != 'rejected';
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_sales_code ON orders(sales_code);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_payment_time ON orders(payment_time DESC) WHERE payment_time IS NOT NULL;

-- 复合索引（常用组合查询）
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_status_created ON orders(status, created_at DESC);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_sales_created ON orders(sales_code, created_at DESC);

-- 预留索引
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_user_id ON orders(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_conversion ON orders(customer_became_sales) WHERE customer_became_sales = TRUE;
```

#### 1.2.3 创建物化视图
```sql
CREATE MATERIALIZED VIEW IF NOT EXISTS orders_with_details AS
SELECT 
  o.*,
  -- 销售信息
  COALESCE(ps.wechat_name, ss.wechat_name) as sales_name,
  COALESCE(ps.commission_rate, ss.commission_rate, 0) as commission_rate,
  CASE 
    WHEN ps.id IS NOT NULL THEN 'primary'
    WHEN ss.primary_sales_id IS NOT NULL THEN 'secondary'
    WHEN ss.id IS NOT NULL THEN 'independent'
    ELSE 'direct'
  END as sales_type,
  -- 客户信息
  c.wechat_name as customer_name,
  c.email as customer_email,
  c.is_sales as customer_is_sales,  -- 预留
  -- 计算佣金
  CASE
    WHEN o.status IN ('confirmed_config', 'active') THEN
      COALESCE(o.actual_payment_amount, o.amount, 0) * 
      COALESCE(ps.commission_rate, ss.commission_rate, 0) / 100
    ELSE 0
  END as calculated_commission
FROM orders o
LEFT JOIN primary_sales ps ON o.primary_sales_id = ps.id
LEFT JOIN secondary_sales ss ON o.secondary_sales_id = ss.id
LEFT JOIN customers c ON o.customer_id = c.id;

-- 创建索引
CREATE UNIQUE INDEX ON orders_with_details (id);
CREATE INDEX ON orders_with_details (status);
CREATE INDEX ON orders_with_details (sales_code);
CREATE INDEX ON orders_with_details (created_at DESC);

-- 自动刷新（每5分钟）
CREATE OR REPLACE FUNCTION refresh_orders_view()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY orders_with_details;
END;
$$ LANGUAGE plpgsql;

-- 创建定时任务（需要pg_cron扩展）
-- SELECT cron.schedule('refresh-orders', '*/5 * * * *', 'SELECT refresh_orders_view()');
```

### 1.3 缓存层实现

```javascript
// ordersCache.js - 完整实现
class OrdersCacheManager {
  constructor() {
    this.cache = new Map();
    this.indexes = {
      byStatus: new Map(),
      bySales: new Map(),
      byCustomer: new Map(),
      byDate: new Map(),
      byOrderNumber: new Map()
    };
    this.cacheDuration = 3 * 60 * 1000; // 3分钟
    this.stats = {
      hits: 0,
      misses: 0,
      updates: 0
    };
  }

  // 批量处理优化
  async batchProcessOrders(orders, salesData) {
    const startTime = Date.now();
    
    // 并行处理
    const processed = await Promise.all(
      orders.map(async order => this.enrichOrder(order, salesData))
    );
    
    // 构建索引
    this.buildIndexes(processed);
    
    const processTime = Date.now() - startTime;
    console.log(`✅ 处理${orders.length}个订单耗时: ${processTime}ms`);
    
    return processed;
  }
  
  // 查询优化
  query(filters = {}) {
    const { status, sales_code, customer, date_range, search } = filters;
    
    // 使用索引快速查询
    if (status && this.indexes.byStatus.has(status)) {
      this.stats.hits++;
      return this.indexes.byStatus.get(status);
    }
    
    if (sales_code && this.indexes.bySales.has(sales_code)) {
      this.stats.hits++;
      return this.indexes.bySales.get(sales_code);
    }
    
    // 降级到过滤查询
    this.stats.misses++;
    return this.filterOrders(filters);
  }
  
  // 单条更新（不刷新整个列表）
  updateSingle(orderId, updates) {
    const order = this.cache.get(`order_${orderId}`);
    if (order) {
      Object.assign(order, updates);
      this.rebuildIndexForOrder(order);
      this.stats.updates++;
    }
  }
  
  // 获取缓存统计
  getStats() {
    const hitRate = this.stats.hits / (this.stats.hits + this.stats.misses) * 100;
    return {
      ...this.stats,
      hitRate: `${hitRate.toFixed(2)}%`,
      cacheSize: this.cache.size
    };
  }
}

export default new OrdersCacheManager();
```

### 1.4 API优化

```javascript
// api.js - getOrders优化
async getOrders(params = {}) {
  const { 
    page = 1, 
    limit = 100, 
    status, 
    sales_code, 
    date_range,
    use_cache = true 
  } = params;
  
  // 1. 缓存策略
  if (use_cache) {
    const cached = ordersCacheManager.query(params);
    if (cached) {
      console.log('📦 订单缓存命中');
      return cached;
    }
  }
  
  // 2. 使用物化视图
  let query = supabase
    .from('orders_with_details')
    .select('*', { count: 'exact' });
  
  // 3. 智能筛选
  if (status && status !== 'all') {
    query = query.eq('status', status);
  }
  
  if (sales_code) {
    query = query.eq('sales_code', sales_code);
  }
  
  if (date_range) {
    const { start, end } = date_range;
    query = query.gte('created_at', start).lte('created_at', end);
  }
  
  // 4. 分页优化
  query = query
    .order('created_at', { ascending: false })
    .range((page - 1) * limit, page * limit - 1);
  
  const { data, count, error } = await query;
  
  if (!error && data) {
    // 5. 更新缓存
    const processed = await ordersCacheManager.batchProcessOrders(data, {
      primary: await this.getPrimarySales(),
      secondary: await this.getSecondarySales()
    });
    
    return { 
      data: processed, 
      count,
      page,
      total_pages: Math.ceil(count / limit)
    };
  }
  
  throw error;
}
```

### 1.5 前端优化

```javascript
// AdminOrders.js - 完整优化
import { useState, useCallback, useMemo, useEffect } from 'react';
import { Table, Button, Select, DatePicker, message } from 'antd';
import { FixedSizeList } from 'react-window'; // 虚拟滚动

const AdminOrders = () => {
  const [orders, setOrders] = useState([]);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState({
    status: 'all',
    sales_code: null,
    date_range: null
  });
  const [pagination, setPagination] = useState({
    current: 1,
    pageSize: 100,
    total: 0
  });
  
  // 优化：使用虚拟滚动处理大数据量
  const VirtualTable = useCallback(({ columns, dataSource }) => {
    const Row = ({ index, style }) => (
      <div style={style}>
        <Table.Row>
          {columns.map(col => (
            <Table.Cell key={col.key}>
              {dataSource[index][col.dataIndex]}
            </Table.Cell>
          ))}
        </Table.Row>
      </div>
    );
    
    return (
      <FixedSizeList
        height={600}
        itemCount={dataSource.length}
        itemSize={60}
        width="100%"
      >
        {Row}
      </FixedSizeList>
    );
  }, []);
  
  // 优化：批量状态更新
  const batchUpdateStatus = useCallback(async (orderIds, newStatus) => {
    // 乐观UI更新
    setOrders(prev => prev.map(order => 
      orderIds.includes(order.id) 
        ? { ...order, status: newStatus, updating: true }
        : order
    ));
    
    try {
      // 批量API调用
      const batchSize = 10;
      for (let i = 0; i < orderIds.length; i += batchSize) {
        const batch = orderIds.slice(i, i + batchSize);
        await Promise.all(
          batch.map(id => adminAPI.updateOrderStatus(id, newStatus))
        );
      }
      
      message.success(`成功更新${orderIds.length}个订单`);
      
      // 更新缓存
      orderIds.forEach(id => {
        ordersCacheManager.updateSingle(id, { status: newStatus });
      });
      
    } catch (error) {
      message.error('更新失败，正在回滚...');
      // 回滚UI
      await loadData();
    }
  }, []);
  
  // 优化：智能加载数据
  const loadData = useCallback(async () => {
    setLoading(true);
    try {
      const result = await adminAPI.getOrders({
        ...filters,
        page: pagination.current,
        limit: pagination.pageSize
      });
      
      setOrders(result.data);
      setPagination(prev => ({
        ...prev,
        total: result.count
      }));
      
    } catch (error) {
      message.error('加载失败');
    } finally {
      setLoading(false);
    }
  }, [filters, pagination.current, pagination.pageSize]);
  
  // 优化：防抖搜索
  const debouncedSearch = useMemo(
    () => debounce((value) => {
      setFilters(prev => ({ ...prev, search: value }));
    }, 500),
    []
  );
  
  // 性能监控
  useEffect(() => {
    const stats = ordersCacheManager.getStats();
    console.log('📊 缓存统计:', stats);
  }, [orders]);
  
  return (
    <div>
      {/* 筛选器 */}
      <div className="filters">
        <Select 
          value={filters.status}
          onChange={v => setFilters(prev => ({ ...prev, status: v }))}
          options={[
            { value: 'all', label: '全部' },
            { value: 'pending_payment', label: '待付款' },
            { value: 'pending_config', label: '待配置' },
            { value: 'confirmed_config', label: '已完成' }
          ]}
        />
        <DatePicker.RangePicker 
          onChange={(dates) => setFilters(prev => ({ 
            ...prev, 
            date_range: dates ? {
              start: dates[0].format('YYYY-MM-DD'),
              end: dates[1].format('YYYY-MM-DD')
            } : null
          }))}
        />
      </div>
      
      {/* 虚拟滚动表格 */}
      <VirtualTable 
        columns={columns}
        dataSource={orders}
        loading={loading}
      />
      
      {/* 分页 */}
      <Pagination 
        {...pagination}
        onChange={(page, pageSize) => {
          setPagination(prev => ({ ...prev, current: page, pageSize }));
        }}
      />
    </div>
  );
};
```

### 1.6 预期效果

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 首次加载 | 2-4秒 | <0.5秒 | 87.5% |
| 翻页响应 | 1-2秒 | <100ms | 95% |
| 状态更新 | 刷新页面 | 即时更新 | 100% |
| 内存占用 | 50MB | 20MB | 60% |
| 缓存命中率 | 0% | >85% | - |

---

## 二、销售管理页面优化（AdminSales）

### 2.1 现状问题分析
- **加载时间**: 2-3秒
- **数据量**: 24个销售，每个需要计算订单统计
- **性能瓶颈**:
  - 循环查询每个销售的订单
  - 实时计算佣金和业绩
  - 销售层级关系复杂
  - 无缓存机制

### 2.2 数据库优化方案

#### 2.2.1 预留字段
```sql
-- primary_sales表预留字段
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS user_id INTEGER;
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS allow_recruit BOOLEAN DEFAULT TRUE;
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS max_secondary_count INTEGER DEFAULT 100;
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS recruit_link VARCHAR(255);
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS purchase_link VARCHAR(255);
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS total_recruited INTEGER DEFAULT 0;
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS last_active_date DATE;
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS monthly_target DECIMAL(10,2);
ALTER TABLE primary_sales ADD COLUMN IF NOT EXISTS achievement_rate DECIMAL(5,2);

-- secondary_sales表预留字段
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS user_id INTEGER;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS source_type VARCHAR(50);
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS converted_from_order_id INTEGER;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS converted_from_customer_id INTEGER;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS conversion_date TIMESTAMP;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS parent_commission_rate DECIMAL(5,2);
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS allow_recruit BOOLEAN DEFAULT FALSE;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS payment_qr_code TEXT;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS payment_info TEXT;
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS bank_account VARCHAR(255);
ALTER TABLE secondary_sales ADD COLUMN IF NOT EXISTS bank_name VARCHAR(100);
```

#### 2.2.2 创建销售统计表
```sql
-- 已完成的sales_statistics表
CREATE TABLE IF NOT EXISTS sales_statistics (
  id SERIAL PRIMARY KEY,
  sales_id INTEGER NOT NULL,
  sales_type VARCHAR(20) NOT NULL,
  sales_code VARCHAR(50) NOT NULL,
  
  -- 订单统计
  total_orders INTEGER DEFAULT 0,
  valid_orders INTEGER DEFAULT 0,
  pending_orders INTEGER DEFAULT 0,
  rejected_orders INTEGER DEFAULT 0,
  
  -- 金额统计
  total_amount DECIMAL(10,2) DEFAULT 0,
  confirmed_amount DECIMAL(10,2) DEFAULT 0,
  pending_amount DECIMAL(10,2) DEFAULT 0,
  
  -- 佣金统计
  commission_rate DECIMAL(5,2),
  commission_amount DECIMAL(10,2) DEFAULT 0,
  paid_commission DECIMAL(10,2) DEFAULT 0,
  pending_commission DECIMAL(10,2) DEFAULT 0,
  
  -- 客户统计
  total_customers INTEGER DEFAULT 0,
  new_customers_month INTEGER DEFAULT 0,
  
  -- 转化统计
  conversion_rate DECIMAL(5,2) DEFAULT 0,
  recruited_count INTEGER DEFAULT 0,
  
  -- 时间统计
  first_order_date DATE,
  last_order_date DATE,
  last_updated TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(sales_id, sales_type)
);

-- 创建索引
CREATE INDEX idx_sales_stats_code ON sales_statistics(sales_code);
CREATE INDEX idx_sales_stats_type ON sales_statistics(sales_type);
CREATE INDEX idx_sales_stats_updated ON sales_statistics(last_updated);
```

#### 2.2.3 创建更新触发器
```sql
-- 自动更新销售统计
CREATE OR REPLACE FUNCTION update_sales_statistics()
RETURNS TRIGGER AS $$
DECLARE
  v_sales_id INTEGER;
  v_sales_type VARCHAR(20);
  v_sales_code VARCHAR(50);
BEGIN
  -- 获取销售信息
  IF NEW.primary_sales_id IS NOT NULL THEN
    v_sales_id := NEW.primary_sales_id;
    v_sales_type := 'primary';
    SELECT sales_code INTO v_sales_code FROM primary_sales WHERE id = v_sales_id;
  ELSIF NEW.secondary_sales_id IS NOT NULL THEN
    v_sales_id := NEW.secondary_sales_id;
    v_sales_type := 'secondary';
    SELECT sales_code INTO v_sales_code FROM secondary_sales WHERE id = v_sales_id;
  ELSE
    RETURN NEW;
  END IF;
  
  -- 更新统计
  INSERT INTO sales_statistics (
    sales_id, sales_type, sales_code,
    total_orders, valid_orders, total_amount, confirmed_amount
  )
  SELECT 
    v_sales_id,
    v_sales_type,
    v_sales_code,
    COUNT(*),
    COUNT(*) FILTER (WHERE status != 'rejected'),
    SUM(amount),
    SUM(CASE WHEN status = 'confirmed_config' THEN amount ELSE 0 END)
  FROM orders
  WHERE (primary_sales_id = v_sales_id OR secondary_sales_id = v_sales_id)
  ON CONFLICT (sales_id, sales_type) 
  DO UPDATE SET
    total_orders = EXCLUDED.total_orders,
    valid_orders = EXCLUDED.valid_orders,
    total_amount = EXCLUDED.total_amount,
    confirmed_amount = EXCLUDED.confirmed_amount,
    last_updated = NOW();
    
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER trg_update_sales_stats
AFTER INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION update_sales_statistics();
```

### 2.3 缓存层实现

```javascript
// salesCache.js - 完整实现
class SalesCacheManager {
  constructor() {
    this.cache = new Map();
    this.cacheDuration = 5 * 60 * 1000; // 5分钟
    this.hierarchyMap = new Map(); // 销售层级关系
  }
  
  // 批量处理销售数据
  async batchProcessSales(primarySales, secondarySales, orders) {
    const startTime = Date.now();
    
    // 1. 构建订单索引 O(n)
    const ordersBySales = new Map();
    orders.forEach(order => {
      const key = order.sales_code;
      if (!ordersBySales.has(key)) {
        ordersBySales.set(key, []);
      }
      ordersBySales.get(key).push(order);
    });
    
    // 2. 构建层级关系
    this.buildHierarchy(primarySales, secondarySales);
    
    // 3. 并行处理
    const [processedPrimary, processedSecondary] = await Promise.all([
      this.processPrimarySales(primarySales, ordersBySales),
      this.processSecondarySales(secondarySales, ordersBySales)
    ]);
    
    // 4. 合并结果
    const allSales = [...processedPrimary, ...processedSecondary];
    
    console.log(`✅ 批量处理${allSales.length}个销售耗时: ${Date.now() - startTime}ms`);
    
    // 5. 更新缓存
    this.cache.set('all_sales', allSales);
    this.cache.set('timestamp', Date.now());
    
    return allSales;
  }
  
  // 处理一级销售
  async processPrimarySales(sales, ordersBySales) {
    return sales.map(sale => {
      const orders = ordersBySales.get(sale.sales_code) || [];
      const stats = this.calculateStats(orders);
      const subordinates = this.getSubordinates(sale.id);
      
      return {
        ...sale,
        ...stats,
        sales_type: '一级销售',
        subordinate_count: subordinates.length,
        subordinate_performance: this.calculateSubordinatePerformance(subordinates, ordersBySales),
        team_total: stats.total_amount + this.calculateSubordinatePerformance(subordinates, ordersBySales)
      };
    });
  }
  
  // 计算统计数据
  calculateStats(orders) {
    const validOrders = orders.filter(o => o.status !== 'rejected');
    const confirmedOrders = orders.filter(o => o.status === 'confirmed_config');
    
    return {
      total_orders: orders.length,
      valid_orders: validOrders.length,
      confirmed_orders: confirmedOrders.length,
      total_amount: orders.reduce((sum, o) => sum + (o.amount || 0), 0),
      confirmed_amount: confirmedOrders.reduce((sum, o) => sum + (o.amount || 0), 0),
      conversion_rate: validOrders.length > 0 
        ? (confirmedOrders.length / validOrders.length * 100).toFixed(2)
        : 0
    };
  }
  
  // 获取缓存统计
  getCacheStats() {
    const now = Date.now();
    const timestamp = this.cache.get('timestamp');
    const age = timestamp ? now - timestamp : 0;
    
    return {
      size: this.cache.size,
      age: `${Math.floor(age / 1000)}秒`,
      expired: age > this.cacheDuration
    };
  }
}

export default new SalesCacheManager();
```

### 2.4 API优化

```javascript
// 优化的getSales方法
async getSales(params = {}) {
  const { sales_type, search, sort_by = 'created_at', use_stats_table = true } = params;
  
  // 1. 优先使用统计表
  if (use_stats_table) {
    try {
      const { data: stats } = await supabase
        .from('sales_statistics')
        .select(`
          *,
          primary_sales!inner(wechat_name, phone, email),
          secondary_sales!inner(wechat_name, phone, email)
        `)
        .order(sort_by, { ascending: false });
        
      if (stats) {
        return this.formatSalesFromStats(stats);
      }
    } catch (error) {
      console.warn('统计表查询失败，降级到实时查询', error);
    }
  }
  
  // 2. 降级到缓存查询
  const cached = salesCacheManager.get(params);
  if (cached && !salesCacheManager.isExpired()) {
    console.log('✅ 销售缓存命中');
    return cached;
  }
  
  // 3. 实时查询（批量优化）
  const [primarySales, secondarySales, orders] = await Promise.all([
    supabase.from('primary_sales').select('*'),
    supabase.from('secondary_sales').select('*'),
    supabase.from('orders').select('*').neq('status', 'rejected')
  ]);
  
  // 4. 批量处理
  const processed = await salesCacheManager.batchProcessSales(
    primarySales.data,
    secondarySales.data,
    orders.data
  );
  
  return processed;
}
```

### 2.5 预期效果

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 加载时间 | 2-3秒 | <0.5秒 | 83% |
| 数据库查询 | 25+ | 3个 | 88% |
| 缓存命中率 | 0% | >90% | - |
| 实时性 | 每次查询 | 5分钟更新 | - |

---

## 三、客户管理页面优化（AdminCustomers）

### 3.1 现状问题分析
- **加载时间**: 1-2秒
- **数据量**: 100+ 客户
- **性能瓶颈**:
  - 客户数据分散在多表
  - 需要计算每个客户的订单统计
  - 搜索功能效率低
  - 无索引支持

### 3.2 数据库优化方案

#### 3.2.1 预留字段
```sql
-- customers表预留字段
ALTER TABLE customers ADD COLUMN IF NOT EXISTS user_id INTEGER;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS is_sales BOOLEAN DEFAULT FALSE;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS sales_type VARCHAR(20);
ALTER TABLE customers ADD COLUMN IF NOT EXISTS became_sales_at TIMESTAMP;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS sales_code VARCHAR(50);
ALTER TABLE customers ADD COLUMN IF NOT EXISTS sales_link VARCHAR(255);
ALTER TABLE customers ADD COLUMN IF NOT EXISTS parent_sales_id INTEGER;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS parent_sales_type VARCHAR(20);
ALTER TABLE customers ADD COLUMN IF NOT EXISTS commission_rate DECIMAL(5,2);
ALTER TABLE customers ADD COLUMN IF NOT EXISTS payment_qr_code TEXT;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS payment_address TEXT;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS total_earned_commission DECIMAL(10,2) DEFAULT 0;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS pending_commission DECIMAL(10,2) DEFAULT 0;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS last_purchase_date DATE;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS lifetime_value DECIMAL(10,2) DEFAULT 0;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS referral_count INTEGER DEFAULT 0;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS vip_level INTEGER DEFAULT 0;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS tags TEXT[];  -- 标签数组
```

#### 3.2.2 创建客户统计视图
```sql
CREATE MATERIALIZED VIEW IF NOT EXISTS customer_stats AS
SELECT 
  c.id,
  c.wechat_name,
  c.email,
  c.phone,
  c.created_at,
  c.is_sales,  -- 预留
  c.sales_code as customer_sales_code,  -- 预留
  -- 订单统计
  COUNT(DISTINCT o.id) as total_orders,
  COUNT(DISTINCT o.id) FILTER (WHERE o.status != 'rejected') as valid_orders,
  COUNT(DISTINCT o.id) FILTER (WHERE o.status = 'confirmed_config') as confirmed_orders,
  -- 金额统计
  COALESCE(SUM(o.amount), 0) as total_spent,
  COALESCE(SUM(o.amount) FILTER (WHERE o.status = 'confirmed_config'), 0) as confirmed_spent,
  COALESCE(AVG(o.amount), 0) as avg_order_value,
  -- 时间统计
  MAX(o.created_at) as last_order_date,
  MIN(o.created_at) as first_order_date,
  EXTRACT(DAY FROM NOW() - MAX(o.created_at)) as days_since_last_order,
  -- 销售归属
  o.sales_code,
  COALESCE(ps.wechat_name, ss.wechat_name) as sales_name,
  CASE 
    WHEN ps.id IS NOT NULL THEN 'primary'
    WHEN ss.id IS NOT NULL THEN 'secondary'
    ELSE 'direct'
  END as sales_type,
  -- 客户价值分层
  CASE
    WHEN SUM(o.amount) > 5000 THEN 'VIP'
    WHEN SUM(o.amount) > 2000 THEN '高价值'
    WHEN SUM(o.amount) > 500 THEN '普通'
    ELSE '潜在'
  END as customer_level
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
LEFT JOIN primary_sales ps ON o.primary_sales_id = ps.id
LEFT JOIN secondary_sales ss ON o.secondary_sales_id = ss.id
GROUP BY c.id, o.sales_code, ps.wechat_name, ss.wechat_name, ps.id, ss.id;

-- 创建索引
CREATE UNIQUE INDEX ON customer_stats (id);
CREATE INDEX ON customer_stats (sales_code);
CREATE INDEX ON customer_stats (customer_level);
CREATE INDEX ON customer_stats (last_order_date DESC);

-- 全文搜索索引
CREATE INDEX idx_customer_search ON customers 
USING gin(to_tsvector('simple', 
  COALESCE(wechat_name, '') || ' ' || 
  COALESCE(email, '') || ' ' || 
  COALESCE(phone, '')
));
```

### 3.3 缓存层实现

```javascript
// customerCache.js
class CustomerCacheManager {
  constructor() {
    this.cache = new Map();
    this.searchCache = new Map();
    this.cacheDuration = 10 * 60 * 1000; // 10分钟
  }
  
  // 批量处理客户数据
  batchProcessCustomers(customers, orders) {
    // 构建订单索引
    const ordersByCustomer = new Map();
    orders.forEach(order => {
      const key = order.customer_id;
      if (!ordersByCustomer.has(key)) {
        ordersByCustomer.set(key, []);
      }
      ordersByCustomer.get(key).push(order);
    });
    
    // 处理每个客户
    return customers.map(customer => {
      const customerOrders = ordersByCustomer.get(customer.id) || [];
      const stats = this.calculateCustomerStats(customerOrders);
      
      return {
        ...customer,
        ...stats,
        value_score: this.calculateValueScore(stats),
        risk_level: this.calculateRiskLevel(stats)
      };
    });
  }
  
  // 智能搜索
  search(keyword) {
    // 检查缓存
    if (this.searchCache.has(keyword)) {
      return this.searchCache.get(keyword);
    }
    
    // 模糊搜索
    const results = this.fuzzySearch(keyword);
    
    // 缓存结果
    this.searchCache.set(keyword, results);
    return results;
  }
  
  // 模糊搜索实现
  fuzzySearch(keyword) {
    const customers = this.cache.get('all_customers') || [];
    const lowerKeyword = keyword.toLowerCase();
    
    return customers.filter(c => {
      const searchText = `${c.wechat_name} ${c.email} ${c.phone}`.toLowerCase();
      return searchText.includes(lowerKeyword);
    }).sort((a, b) => {
      // 优先级排序：完全匹配 > 开头匹配 > 包含匹配
      const aScore = this.getMatchScore(a, lowerKeyword);
      const bScore = this.getMatchScore(b, lowerKeyword);
      return bScore - aScore;
    });
  }
}
```

### 3.4 预期效果

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 加载时间 | 1-2秒 | <0.3秒 | 85% |
| 搜索响应 | 500ms | <50ms | 90% |
| 数据完整性 | 基础信息 | 全面统计 | 100% |

---

## 四、资金统计页面优化（AdminFinance）

### 4.1 现状问题分析
- **加载时间**: 3-5秒
- **计算复杂度**: 高
- **性能瓶颈**:
  - 实时计算所有财务指标
  - 聚合大量历史数据
  - 多维度统计耗时
  - 无预计算机制

### 4.2 数据库优化方案

#### 4.2.1 创建财务统计表
```sql
-- 日统计表
CREATE TABLE IF NOT EXISTS finance_daily_stats (
  stat_date DATE PRIMARY KEY,
  
  -- 订单统计
  total_orders INTEGER DEFAULT 0,
  valid_orders INTEGER DEFAULT 0,
  confirmed_orders INTEGER DEFAULT 0,
  rejected_orders INTEGER DEFAULT 0,
  
  -- 收入统计
  total_revenue DECIMAL(10,2) DEFAULT 0,
  confirmed_revenue DECIMAL(10,2) DEFAULT 0,
  pending_revenue DECIMAL(10,2) DEFAULT 0,
  refunded_amount DECIMAL(10,2) DEFAULT 0,
  
  -- 佣金统计
  total_commission DECIMAL(10,2) DEFAULT 0,
  paid_commission DECIMAL(10,2) DEFAULT 0,
  pending_commission DECIMAL(10,2) DEFAULT 0,
  
  -- 利润统计
  gross_profit DECIMAL(10,2) DEFAULT 0,
  net_profit DECIMAL(10,2) DEFAULT 0,
  profit_margin DECIMAL(5,2) DEFAULT 0,
  
  -- 支付方式分布
  alipay_amount DECIMAL(10,2) DEFAULT 0,
  wechat_amount DECIMAL(10,2) DEFAULT 0,
  bank_amount DECIMAL(10,2) DEFAULT 0,
  
  -- 销售业绩
  primary_sales_amount DECIMAL(10,2) DEFAULT 0,
  secondary_sales_amount DECIMAL(10,2) DEFAULT 0,
  direct_sales_amount DECIMAL(10,2) DEFAULT 0,
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 月统计表
CREATE TABLE IF NOT EXISTS finance_monthly_stats (
  stat_month VARCHAR(7) PRIMARY KEY,  -- YYYY-MM
  
  -- 汇总统计
  total_days INTEGER,
  working_days INTEGER,
  total_orders INTEGER,
  total_revenue DECIMAL(10,2),
  total_commission DECIMAL(10,2),
  total_profit DECIMAL(10,2),
  
  -- 平均统计
  avg_daily_revenue DECIMAL(10,2),
  avg_order_value DECIMAL(10,2),
  avg_commission_rate DECIMAL(5,2),
  
  -- 增长统计
  revenue_growth_rate DECIMAL(5,2),  -- 环比
  order_growth_rate DECIMAL(5,2),
  yoy_growth_rate DECIMAL(5,2),  -- 同比
  
  -- 目标达成
  revenue_target DECIMAL(10,2),
  achievement_rate DECIMAL(5,2),
  
  created_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_finance_daily_date ON finance_daily_stats(stat_date DESC);
CREATE INDEX idx_finance_monthly ON finance_monthly_stats(stat_month DESC);
```

#### 4.2.2 创建返佣记录表
```sql
CREATE TABLE IF NOT EXISTS commission_records (
  id SERIAL PRIMARY KEY,
  
  -- 订单信息
  order_id INTEGER NOT NULL REFERENCES orders(id),
  order_number VARCHAR(50),
  order_amount DECIMAL(10,2),
  
  -- 销售信息
  sales_id INTEGER NOT NULL,
  sales_type VARCHAR(20) NOT NULL,
  sales_code VARCHAR(50) NOT NULL,
  sales_name VARCHAR(100),
  user_id INTEGER,  -- 预留
  
  -- 返佣信息
  commission_rate DECIMAL(5,2) NOT NULL,
  commission_amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(10) DEFAULT 'USD',
  
  -- 状态管理
  status VARCHAR(20) DEFAULT 'pending',  -- pending/approved/paid/cancelled
  approved_at TIMESTAMP,
  approved_by INTEGER,
  paid_at TIMESTAMP,
  payment_method VARCHAR(50),
  payment_reference VARCHAR(255),
  payment_proof TEXT,
  
  -- 层级信息
  is_secondary BOOLEAN DEFAULT FALSE,
  parent_sales_id INTEGER,
  parent_commission_amount DECIMAL(10,2),
  
  -- 特殊标记
  is_customer_upgrade BOOLEAN DEFAULT FALSE,  -- 客户转化订单
  source_type VARCHAR(50),
  notes TEXT,
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_commission_order ON commission_records(order_id);
CREATE INDEX idx_commission_sales ON commission_records(sales_id, sales_type);
CREATE INDEX idx_commission_status ON commission_records(status);
CREATE INDEX idx_commission_date ON commission_records(created_at DESC);
CREATE INDEX idx_commission_paid ON commission_records(paid_at DESC) WHERE paid_at IS NOT NULL;
```

#### 4.2.3 创建自动统计函数
```sql
-- 每日统计更新函数
CREATE OR REPLACE FUNCTION update_daily_finance_stats(p_date DATE)
RETURNS void AS $$
BEGIN
  INSERT INTO finance_daily_stats (
    stat_date,
    total_orders,
    valid_orders,
    total_revenue,
    confirmed_revenue,
    total_commission,
    paid_commission,
    pending_commission
  )
  SELECT 
    p_date,
    COUNT(*),
    COUNT(*) FILTER (WHERE status != 'rejected'),
    SUM(amount),
    SUM(amount) FILTER (WHERE status = 'confirmed_config'),
    SUM(commission_amount),
    SUM(paid_commission),
    SUM(commission_amount - COALESCE(paid_commission, 0))
  FROM orders
  LEFT JOIN commission_records cr ON orders.id = cr.order_id
  WHERE DATE(orders.created_at) = p_date
  ON CONFLICT (stat_date) DO UPDATE SET
    total_orders = EXCLUDED.total_orders,
    valid_orders = EXCLUDED.valid_orders,
    total_revenue = EXCLUDED.total_revenue,
    confirmed_revenue = EXCLUDED.confirmed_revenue,
    total_commission = EXCLUDED.total_commission,
    paid_commission = EXCLUDED.paid_commission,
    pending_commission = EXCLUDED.pending_commission,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- 定时任务（每日凌晨1点执行）
-- SELECT cron.schedule('daily-finance-stats', '0 1 * * *', 
--   'SELECT update_daily_finance_stats(CURRENT_DATE - INTERVAL ''1 day'')');
```

### 4.3 缓存层实现

```javascript
// financeCache.js
class FinanceCacheManager {
  constructor() {
    this.cache = new Map();
    this.cacheDuration = 15 * 60 * 1000; // 15分钟
  }
  
  // 获取财务统计
  async getFinanceStats(dateRange) {
    const cacheKey = `finance_${dateRange.start}_${dateRange.end}`;
    
    // 检查缓存
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheDuration) {
        return cached.data;
      }
    }
    
    // 查询统计表
    const stats = await this.queryFinanceStats(dateRange);
    
    // 更新缓存
    this.cache.set(cacheKey, {
      data: stats,
      timestamp: Date.now()
    });
    
    return stats;
  }
  
  // 查询财务统计
  async queryFinanceStats(dateRange) {
    // 根据日期范围选择查询策略
    const days = this.getDaysBetween(dateRange.start, dateRange.end);
    
    if (days <= 31) {
      // 查询日统计表
      return this.queryDailyStats(dateRange);
    } else if (days <= 365) {
      // 查询月统计表
      return this.queryMonthlyStats(dateRange);
    } else {
      // 查询年度统计
      return this.queryYearlyStats(dateRange);
    }
  }
  
  // 实时计算（降级方案）
  async calculateRealtime(dateRange) {
    const { data: orders } = await supabase
      .from('orders')
      .select('*')
      .gte('created_at', dateRange.start)
      .lte('created_at', dateRange.end);
      
    return this.aggregateOrders(orders);
  }
}
```

### 4.4 预期效果

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 日报生成 | 3-5秒 | <0.5秒 | 90% |
| 月报生成 | 5-8秒 | <1秒 | 87.5% |
| 实时统计 | 每次计算 | 预计算+缓存 | 95% |

---

## 五、销售对账页面（新增）

### 5.1 一级销售对账页面

#### 5.1.1 功能设计
```javascript
// 一级销售看到的数据
{
  // 个人业绩
  personal: {
    total_orders: 150,
    total_amount: 28800,
    commission_rate: 40,
    commission_amount: 11520,
    paid_commission: 8000,
    pending_commission: 3520
  },
  
  // 团队业绩（二级销售）
  team: {
    member_count: 5,
    total_orders: 80,
    total_amount: 15000,
    team_commission: 3750,  // 从二级销售订单获得的佣金
    paid_team_commission: 2000,
    pending_team_commission: 1750
  },
  
  // 明细列表
  orders: [...],  // 个人订单明细
  team_orders: [...],  // 团队订单明细
  
  // 结算记录
  settlements: [...]  // 历史结算记录
}
```

#### 5.1.2 数据库查询优化
```sql
-- 创建一级销售对账视图
CREATE MATERIALIZED VIEW primary_sales_reconciliation AS
SELECT 
  ps.id as sales_id,
  ps.sales_code,
  ps.wechat_name,
  
  -- 个人业绩
  COUNT(DISTINCT o1.id) as personal_orders,
  SUM(o1.amount) as personal_amount,
  ps.commission_rate as personal_rate,
  SUM(o1.amount * ps.commission_rate / 100) as personal_commission,
  
  -- 团队业绩
  COUNT(DISTINCT ss.id) as team_members,
  COUNT(DISTINCT o2.id) as team_orders,
  SUM(o2.amount) as team_amount,
  SUM(o2.amount * ss.commission_rate / 100 * 0.15) as team_commission,  -- 假设15%团队分成
  
  -- 已支付佣金
  SUM(cr1.commission_amount) FILTER (WHERE cr1.status = 'paid') as paid_personal,
  SUM(cr2.commission_amount) FILTER (WHERE cr2.status = 'paid') as paid_team,
  
  -- 待支付佣金
  SUM(cr1.commission_amount) FILTER (WHERE cr1.status = 'pending') as pending_personal,
  SUM(cr2.commission_amount) FILTER (WHERE cr2.status = 'pending') as pending_team
  
FROM primary_sales ps
LEFT JOIN orders o1 ON o1.primary_sales_id = ps.id
LEFT JOIN secondary_sales ss ON ss.primary_sales_id = ps.id
LEFT JOIN orders o2 ON o2.secondary_sales_id = ss.id
LEFT JOIN commission_records cr1 ON cr1.order_id = o1.id AND cr1.sales_id = ps.id
LEFT JOIN commission_records cr2 ON cr2.order_id = o2.id AND cr2.parent_sales_id = ps.id
GROUP BY ps.id, ps.sales_code, ps.wechat_name, ps.commission_rate;

-- 创建索引
CREATE INDEX ON primary_sales_reconciliation(sales_id);
CREATE INDEX ON primary_sales_reconciliation(sales_code);
```

### 5.2 二级/独立销售对账页面

#### 5.2.1 功能设计
```javascript
// 二级/独立销售看到的数据
{
  // 个人业绩
  personal: {
    total_orders: 50,
    total_amount: 9500,
    commission_rate: 25,  // 二级销售25%，独立销售10%
    commission_amount: 2375,
    paid_commission: 1500,
    pending_commission: 875
  },
  
  // 上级信息（如果有）
  parent: {
    sales_name: '张三',
    sales_code: 'PRI001',
    your_contribution: 1425  // 给上级贡献的佣金
  },
  
  // 订单明细
  orders: [...],
  
  // 结算记录
  settlements: [...]
}
```

#### 5.2.2 数据库查询优化
```sql
-- 创建二级销售对账视图
CREATE MATERIALIZED VIEW secondary_sales_reconciliation AS
SELECT 
  ss.id as sales_id,
  ss.sales_code,
  ss.wechat_name,
  ss.primary_sales_id,
  ps.wechat_name as parent_name,
  ps.sales_code as parent_code,
  
  -- 个人业绩
  COUNT(DISTINCT o.id) as total_orders,
  SUM(o.amount) as total_amount,
  ss.commission_rate,
  SUM(o.amount * ss.commission_rate / 100) as commission_amount,
  
  -- 给上级的贡献
  SUM(o.amount * ps.commission_rate / 100 * 0.15) as parent_contribution,
  
  -- 支付状态
  SUM(cr.commission_amount) FILTER (WHERE cr.status = 'paid') as paid_commission,
  SUM(cr.commission_amount) FILTER (WHERE cr.status = 'pending') as pending_commission
  
FROM secondary_sales ss
LEFT JOIN primary_sales ps ON ss.primary_sales_id = ps.id
LEFT JOIN orders o ON o.secondary_sales_id = ss.id
LEFT JOIN commission_records cr ON cr.order_id = o.id AND cr.sales_id = ss.id
GROUP BY ss.id, ss.sales_code, ss.wechat_name, ss.primary_sales_id, 
         ps.wechat_name, ps.sales_code, ss.commission_rate;

-- 创建索引
CREATE INDEX ON secondary_sales_reconciliation(sales_id);
CREATE INDEX ON secondary_sales_reconciliation(sales_code);
```

### 5.3 对账页面前端实现

```javascript
// SalesReconciliation.js - 销售对账页面
import React, { useState, useEffect } from 'react';
import { Card, Table, Statistic, Row, Col, DatePicker, Button } from 'antd';

const SalesReconciliation = ({ salesType, salesCode }) => {
  const [data, setData] = useState(null);
  const [dateRange, setDateRange] = useState([moment().startOf('month'), moment()]);
  const [loading, setLoading] = useState(false);
  
  // 加载对账数据
  const loadReconciliation = async () => {
    setLoading(true);
    try {
      const result = await api.getSalesReconciliation({
        sales_type: salesType,
        sales_code: salesCode,
        start_date: dateRange[0].format('YYYY-MM-DD'),
        end_date: dateRange[1].format('YYYY-MM-DD')
      });
      setData(result);
    } catch (error) {
      message.error('加载对账数据失败');
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    loadReconciliation();
  }, [dateRange]);
  
  // 导出对账单
  const exportReconciliation = () => {
    const csv = generateCSV(data);
    downloadCSV(csv, `对账单_${salesCode}_${moment().format('YYYYMMDD')}.csv`);
  };
  
  return (
    <div className="sales-reconciliation">
      {/* 统计卡片 */}
      <Row gutter={16}>
        <Col span={6}>
          <Card>
            <Statistic 
              title="总订单数" 
              value={data?.personal.total_orders} 
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic 
              title="总金额" 
              value={data?.personal.total_amount} 
              prefix="$"
              precision={2}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic 
              title="应得佣金" 
              value={data?.personal.commission_amount} 
              prefix="$"
              precision={2}
              valueStyle={{ color: '#3f8600' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic 
              title="待结算" 
              value={data?.personal.pending_commission} 
              prefix="$"
              precision={2}
              valueStyle={{ color: '#cf1322' }}
            />
          </Card>
        </Col>
      </Row>
      
      {/* 团队业绩（仅一级销售） */}
      {salesType === 'primary' && data?.team && (
        <Card title="团队业绩" style={{ marginTop: 16 }}>
          <Row gutter={16}>
            <Col span={6}>
              <Statistic title="团队成员" value={data.team.member_count} />
            </Col>
            <Col span={6}>
              <Statistic title="团队订单" value={data.team.total_orders} />
            </Col>
            <Col span={6}>
              <Statistic 
                title="团队佣金" 
                value={data.team.team_commission} 
                prefix="$"
              />
            </Col>
          </Row>
        </Card>
      )}
      
      {/* 订单明细 */}
      <Card title="订单明细" style={{ marginTop: 16 }}>
        <Table 
          columns={[
            { title: '订单号', dataIndex: 'order_number', key: 'order_number' },
            { title: '客户', dataIndex: 'customer_name', key: 'customer_name' },
            { title: '金额', dataIndex: 'amount', key: 'amount', render: v => `$${v}` },
            { title: '佣金率', dataIndex: 'commission_rate', key: 'commission_rate', render: v => `${v}%` },
            { title: '佣金', dataIndex: 'commission', key: 'commission', render: v => `$${v}` },
            { title: '状态', dataIndex: 'status', key: 'status' },
            { title: '日期', dataIndex: 'created_at', key: 'created_at' }
          ]}
          dataSource={data?.orders}
          loading={loading}
        />
      </Card>
      
      {/* 操作按钮 */}
      <div style={{ marginTop: 16, textAlign: 'right' }}>
        <Button onClick={exportReconciliation} type="primary">
          导出对账单
        </Button>
      </div>
    </div>
  );
};

export default SalesReconciliation;
```

---

## 六、测试计划

### 6.1 测试环境准备
```bash
# 1. 创建测试数据库分支
git checkout -b feature/performance-optimization

# 2. 备份当前数据
pg_dump -h your-host -U your-user -d your-db > backup_$(date +%Y%m%d).sql

# 3. 创建测试环境变量
cat > .env.test << EOF
REACT_APP_SUPABASE_URL=your-test-url
REACT_APP_SUPABASE_KEY=your-test-key
REACT_APP_ENABLE_NEW_STATS=true
REACT_APP_ENABLE_CACHE=true
REACT_APP_ENABLE_VIRTUAL_SCROLL=true
EOF
```

### 6.2 测试步骤

#### 第一阶段：数据库优化测试
1. 执行预留字段SQL（安全，使用IF NOT EXISTS）
2. 创建索引（使用CONCURRENTLY，不锁表）
3. 创建物化视图
4. 填充统计表数据
5. 验证查询性能

#### 第二阶段：缓存层测试
1. 部署缓存管理器
2. 测试缓存命中率
3. 验证数据一致性
4. 压力测试

#### 第三阶段：前端优化测试
1. 虚拟滚动测试
2. 批量操作测试
3. 实时更新测试
4. 内存泄漏检测

### 6.3 性能基准测试
```javascript
// performanceTest.js
const runPerformanceTest = async () => {
  const tests = [
    { name: '订单列表加载', fn: testOrdersLoad },
    { name: '销售统计计算', fn: testSalesStats },
    { name: '客户搜索', fn: testCustomerSearch },
    { name: '财务报表生成', fn: testFinanceReport }
  ];
  
  for (const test of tests) {
    console.time(test.name);
    await test.fn();
    console.timeEnd(test.name);
  }
};
```

### 6.4 回滚方案
```sql
-- 如果需要回滚
-- 1. 删除物化视图
DROP MATERIALIZED VIEW IF EXISTS orders_with_details CASCADE;
DROP MATERIALIZED VIEW IF EXISTS customer_stats CASCADE;

-- 2. 删除统计表
DROP TABLE IF EXISTS sales_statistics CASCADE;
DROP TABLE IF EXISTS finance_daily_stats CASCADE;
DROP TABLE IF EXISTS commission_records CASCADE;

-- 3. 删除索引
DROP INDEX IF EXISTS idx_orders_status;
-- ... 其他索引

-- 4. 恢复备份
psql -h your-host -U your-user -d your-db < backup_20241219.sql
```

---

## 七、上线计划

### 7.1 前置条件
- [ ] 所有测试通过
- [ ] 性能提升达标
- [ ] 数据一致性验证
- [ ] 获得您的明确同意

### 7.2 分阶段上线
1. **Phase 1**: 数据库优化（低风险）
2. **Phase 2**: 缓存层部署（中风险）
3. **Phase 3**: 前端优化（低风险）
4. **Phase 4**: 新功能上线（销售对账）

### 7.3 监控指标
- 页面加载时间
- API响应时间
- 数据库查询性能
- 缓存命中率
- 错误率

---

## 八、风险评估

| 风险项 | 影响 | 概率 | 缓解措施 |
|--------|------|------|----------|
| 索引创建锁表 | 高 | 低 | 使用CONCURRENTLY |
| 缓存数据不一致 | 中 | 中 | 设置合理过期时间 |
| 物化视图延迟 | 低 | 中 | 定时刷新+手动刷新 |
| 内存溢出 | 高 | 低 | 虚拟滚动+分页 |

---

**重要提醒**：
1. 所有操作仅在测试环境执行
2. 需要您明确同意才能上线
3. 提供完整回滚方案
4. 分阶段逐步实施

是否同意开始在测试环境执行优化方案？