# 📊 实时数据流与对账系统设计方案

> 创建时间：2025-08-15
> 目的：设计资金统计、销售对账的实时数据流系统

---

## 一、🎯 需求分析

### 当前系统的对账功能：
1. **资金统计（AdminFinance.js）**
   - 显示总收入、实付金额、销售返佣、营利金额
   - 收益分配方案（公户40%、知行35%、子俊25%）
   - 支持时间范围筛选

2. **一级销售对账（PrimarySalesSettlementPage.js）**
   - 显示直销佣金、分销收益
   - 管理二级销售、设置佣金率
   - 查看所有相关订单

3. **二级销售对账（SalesReconciliationPage.js）**
   - 查看自己的订单和佣金
   - 催单功能（即将到期客户）
   - 购买链接生成

### 关键问题：
- **数据都是实时计算** - 每次查询都要聚合计算
- **没有历史记录** - 无法追溯历史对账数据
- **性能问题** - 数据量大时计算缓慢

---

## 二、📊 数据流设计

### 1️⃣ 实时数据流架构
```
用户提交订单 → 订单创建 → 触发器/事件 → 更新多个表
                                    ↓
                            ├─ 更新统计表
                            ├─ 更新对账表
                            ├─ 更新销售业绩表
                            └─ 更新资金流水表
```

### 2️⃣ 数据更新策略
- **实时更新**：订单状态变更时立即更新相关统计
- **批量更新**：每小时批量计算复杂统计
- **异步队列**：使用消息队列避免阻塞主流程

---

## 三、📋 新表结构设计

### 1️⃣ fund_statistics表 - 资金统计表（新建）
```sql
CREATE TABLE fund_statistics (
  id SERIAL PRIMARY KEY,
  
  -- 统计维度
  stat_date DATE NOT NULL,                          -- 统计日期
  stat_type VARCHAR(20) DEFAULT 'daily',            -- daily/monthly/yearly
  
  -- 收入统计
  total_orders INTEGER DEFAULT 0,                   -- 总订单数
  total_revenue DECIMAL(10,2) DEFAULT 0,            -- 总收入
  confirmed_revenue DECIMAL(10,2) DEFAULT 0,        -- 已确认收入
  pending_revenue DECIMAL(10,2) DEFAULT 0,          -- 待确认收入
  
  -- 佣金统计  
  total_commission DECIMAL(10,2) DEFAULT 0,         -- 总佣金
  primary_commission DECIMAL(10,2) DEFAULT 0,       -- 一级销售佣金
  secondary_commission DECIMAL(10,2) DEFAULT 0,     -- 二级销售佣金
  paid_commission DECIMAL(10,2) DEFAULT 0,          -- 已付佣金
  pending_commission DECIMAL(10,2) DEFAULT 0,       -- 待付佣金
  
  -- 营利统计
  net_profit DECIMAL(10,2) DEFAULT 0,               -- 营利金额（收入-佣金）
  
  -- 分配金额（基于实付金额）
  public_amount DECIMAL(10,2) DEFAULT 0,            -- 公户分配金额
  marketing_amount DECIMAL(10,2) DEFAULT 0,         -- 营销费用
  dividend_amount DECIMAL(10,2) DEFAULT 0,          -- 分红
  development_amount DECIMAL(10,2) DEFAULT 0,       -- 开发费用
  zhixing_amount DECIMAL(10,2) DEFAULT 0,           -- 知行分配金额
  zijun_amount DECIMAL(10,2) DEFAULT 0,             -- 子俊分配金额
  
  -- 分配比例（记录当时的比例）
  public_ratio DECIMAL(5,2) DEFAULT 40,             -- 公户占比
  zhixing_ratio DECIMAL(5,2) DEFAULT 35,            -- 知行占比
  zijun_ratio DECIMAL(5,2) DEFAULT 25,              -- 子俊占比
  
  -- 元数据
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_fund_stats_date ON fund_statistics(stat_date, stat_type);
CREATE INDEX idx_fund_stats_type ON fund_statistics(stat_type);
```

### 2️⃣ sales_reconciliation表 - 销售对账表（新建）
```sql
CREATE TABLE sales_reconciliation (
  id SERIAL PRIMARY KEY,
  
  -- 对账主体
  sales_id INTEGER NOT NULL,                        -- 销售ID
  sales_code VARCHAR(50) NOT NULL,                  -- 销售代码
  sales_wechat VARCHAR(100) NOT NULL,               -- 销售微信
  sales_type VARCHAR(20) NOT NULL,                  -- primary/secondary
  
  -- 对账周期
  reconciliation_date DATE NOT NULL,                -- 对账日期
  reconciliation_type VARCHAR(20) DEFAULT 'daily',  -- daily/monthly
  
  -- 订单统计
  total_orders INTEGER DEFAULT 0,                   -- 总订单数
  new_orders INTEGER DEFAULT 0,                     -- 新增订单数
  renewal_orders INTEGER DEFAULT 0,                 -- 续费订单数
  
  -- 金额统计
  total_revenue DECIMAL(10,2) DEFAULT 0,            -- 总销售额
  direct_revenue DECIMAL(10,2) DEFAULT 0,           -- 直销收入
  team_revenue DECIMAL(10,2) DEFAULT 0,             -- 团队销售收入
  
  -- 佣金明细
  commission_rate DECIMAL(5,4),                     -- 佣金率
  base_commission DECIMAL(10,2) DEFAULT 0,          -- 基础佣金
  bonus_commission DECIMAL(10,2) DEFAULT 0,         -- 奖励佣金
  total_commission DECIMAL(10,2) DEFAULT 0,         -- 总佣金
  
  -- 分销收益（仅一级销售）
  distribution_revenue DECIMAL(10,2) DEFAULT 0,     -- 分销总收入
  distribution_commission DECIMAL(10,2) DEFAULT 0,  -- 分销佣金收益
  secondary_sales_count INTEGER DEFAULT 0,          -- 二级销售数量
  
  -- 支付状态
  paid_amount DECIMAL(10,2) DEFAULT 0,              -- 已支付金额
  pending_amount DECIMAL(10,2) DEFAULT 0,           -- 待支付金额
  payment_status VARCHAR(20) DEFAULT 'pending',     -- pending/partial/paid
  last_payment_date TIMESTAMP,                      -- 最后支付时间
  
  -- 对账状态
  reconciliation_status VARCHAR(20) DEFAULT 'draft', -- draft/confirmed/disputed
  confirmed_by INTEGER,                             -- 确认人ID
  confirmed_at TIMESTAMP,                           -- 确认时间
  dispute_reason TEXT,                              -- 争议原因
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_reconciliation_sales ON sales_reconciliation(sales_id, reconciliation_date);
CREATE INDEX idx_reconciliation_status ON sales_reconciliation(reconciliation_status);
```

### 3️⃣ fund_flow表 - 资金流水表（新建）
```sql
CREATE TABLE fund_flow (
  id SERIAL PRIMARY KEY,
  
  -- 流水信息
  flow_number VARCHAR(50) UNIQUE NOT NULL,          -- 流水号
  flow_type VARCHAR(20) NOT NULL,                   -- income/commission/distribution
  flow_direction VARCHAR(10) NOT NULL,              -- in/out
  
  -- 关联信息
  order_id INTEGER,                                 -- 关联订单ID
  sales_id INTEGER,                                 -- 关联销售ID
  customer_id INTEGER,                              -- 关联客户ID
  
  -- 金额信息
  amount DECIMAL(10,2) NOT NULL,                    -- 金额
  currency VARCHAR(10) DEFAULT 'USD',               -- 货币类型
  exchange_rate DECIMAL(10,4) DEFAULT 1,            -- 汇率
  
  -- 账户信息
  from_account VARCHAR(100),                        -- 付款账户
  to_account VARCHAR(100),                          -- 收款账户
  payment_method VARCHAR(20),                       -- 支付方式
  
  -- 分类信息
  category VARCHAR(50),                             -- 收入类别
  sub_category VARCHAR(50),                         -- 子类别
  
  -- 备注
  description TEXT,                                 -- 描述
  remark TEXT,                                      -- 备注
  
  -- 状态
  status VARCHAR(20) DEFAULT 'pending',             -- pending/confirmed/cancelled
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_flow_number ON fund_flow(flow_number);
CREATE INDEX idx_flow_order ON fund_flow(order_id);
CREATE INDEX idx_flow_date ON fund_flow(created_at);
```

### 4️⃣ reminder_records表 - 催单记录表（新建）
```sql
CREATE TABLE reminder_records (
  id SERIAL PRIMARY KEY,
  
  -- 催单信息
  order_id INTEGER NOT NULL,                        -- 订单ID
  customer_wechat VARCHAR(100) NOT NULL,            -- 客户微信
  sales_id INTEGER NOT NULL,                        -- 销售ID
  sales_wechat VARCHAR(100) NOT NULL,               -- 销售微信
  
  -- 催单详情
  reminder_type VARCHAR(20) DEFAULT 'expiry',       -- expiry/payment/renewal
  reminder_method VARCHAR(20) DEFAULT 'offline',    -- offline/online/auto
  reminder_status VARCHAR(20) DEFAULT 'pending',    -- pending/contacted/responded/converted
  
  -- 时间信息
  expiry_date DATE,                                 -- 到期日期
  days_before_expiry INTEGER,                       -- 到期前天数
  reminded_at TIMESTAMP,                            -- 催单时间
  responded_at TIMESTAMP,                           -- 客户响应时间
  
  -- 结果
  response_content TEXT,                            -- 客户响应内容
  conversion_result VARCHAR(20),                    -- renewed/rejected/pending
  new_order_id INTEGER,                             -- 新订单ID（如果续费）
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_reminder_order ON reminder_records(order_id);
CREATE INDEX idx_reminder_sales ON reminder_records(sales_id);
CREATE INDEX idx_reminder_status ON reminder_records(reminder_status);
```

---

## 四、🔄 实时数据流实现

### 1. 订单创建时的数据流
```sql
-- 创建触发器函数
CREATE OR REPLACE FUNCTION on_order_created()
RETURNS TRIGGER AS $$
BEGIN
  -- 1. 更新资金统计表
  INSERT INTO fund_statistics (stat_date, total_orders, total_revenue)
  VALUES (CURRENT_DATE, 1, NEW.amount)
  ON CONFLICT (stat_date, stat_type) 
  DO UPDATE SET 
    total_orders = fund_statistics.total_orders + 1,
    total_revenue = fund_statistics.total_revenue + NEW.amount;
  
  -- 2. 更新销售对账表
  INSERT INTO sales_reconciliation (
    sales_id, sales_code, sales_wechat, 
    reconciliation_date, total_orders, total_revenue
  )
  SELECT 
    s.id, s.sales_code, s.wechat_name,
    CURRENT_DATE, 1, NEW.amount
  FROM secondary_sales s
  WHERE s.sales_code = NEW.sales_code
  ON CONFLICT (sales_id, reconciliation_date, reconciliation_type)
  DO UPDATE SET
    total_orders = sales_reconciliation.total_orders + 1,
    total_revenue = sales_reconciliation.total_revenue + NEW.amount;
  
  -- 3. 创建资金流水记录
  INSERT INTO fund_flow (
    flow_number, flow_type, flow_direction,
    order_id, amount, status
  ) VALUES (
    'FLOW' || TO_CHAR(NOW(), 'YYYYMMDDHH24MISS') || NEW.id,
    'income', 'in',
    NEW.id, NEW.amount, 'pending'
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER trigger_order_created
AFTER INSERT ON orders
FOR EACH ROW EXECUTE FUNCTION on_order_created();
```

### 2. 订单状态变更时的数据流
```sql
-- 订单确认付款时
CREATE OR REPLACE FUNCTION on_payment_confirmed()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'confirmed_payment' AND OLD.status != 'confirmed_payment' THEN
    -- 更新资金统计
    UPDATE fund_statistics 
    SET confirmed_revenue = confirmed_revenue + NEW.amount
    WHERE stat_date = CURRENT_DATE;
    
    -- 计算并分配佣金
    IF NEW.commission_amount > 0 THEN
      -- 更新销售对账表
      UPDATE sales_reconciliation
      SET total_commission = total_commission + NEW.commission_amount
      WHERE sales_id = NEW.sales_id 
        AND reconciliation_date = CURRENT_DATE;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 3. 实时推送到前端
```javascript
// 使用Supabase Realtime订阅
const subscription = supabase
  .channel('orders')
  .on('postgres_changes', 
    { 
      event: '*', 
      schema: 'public', 
      table: 'orders' 
    },
    (payload) => {
      // 实时更新前端显示
      if (payload.eventType === 'INSERT') {
        updateOrderStats(payload.new);
        updateFundStats(payload.new);
      }
    }
  )
  .subscribe();
```

---

## 五、📱 前端实时展示

### 1. 资金统计页面改造
```javascript
// AdminFinance.js 改造
const AdminFinance = () => {
  // 订阅实时数据
  useEffect(() => {
    const channel = supabase.channel('fund-stats');
    
    // 订阅资金统计变化
    channel
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'fund_statistics'
      }, handleFundUpdate)
      .subscribe();
    
    return () => {
      supabase.removeChannel(channel);
    };
  }, []);
  
  // 直接从预计算表读取
  const loadStats = async () => {
    const { data } = await supabase
      .from('fund_statistics')
      .select('*')
      .eq('stat_date', today)
      .single();
    
    setStats(data); // 直接使用，无需计算
  };
};
```

### 2. 销售对账页面改造
```javascript
// 一级销售对账
const loadReconciliation = async (salesCode) => {
  // 直接查询对账表
  const { data } = await supabase
    .from('sales_reconciliation')
    .select('*')
    .eq('sales_code', salesCode)
    .eq('reconciliation_date', today);
  
  return data; // 所有数据已预计算
};
```

---

## 六、✅ 实施步骤

### 第1阶段：创建新表
```sql
-- 1. 创建所有新表
-- 2. 创建索引
-- 3. 设置权限
```

### 第2阶段：历史数据迁移
```sql
-- 迁移历史订单数据到统计表
INSERT INTO fund_statistics (stat_date, total_orders, total_revenue)
SELECT 
  DATE(created_at) as stat_date,
  COUNT(*) as total_orders,
  SUM(amount) as total_revenue
FROM orders
GROUP BY DATE(created_at);
```

### 第3阶段：实时触发器部署
```sql
-- 部署所有触发器
-- 测试数据流
```

### 第4阶段：前端切换
1. 先在测试环境验证
2. 逐步切换各个页面
3. 保留原逻辑作为备份

---

## 七、🎯 效果预期

### 性能提升：
- **查询速度**：从2-3秒降到50ms以内
- **实时性**：数据变更立即反映
- **并发能力**：支持多用户同时查询

### 功能增强：
- **历史追溯**：可查看任意日期的对账数据
- **实时通知**：订单变化实时推送
- **数据一致性**：避免计算误差

### 用户体验：
- **即时响应**：页面秒开
- **实时更新**：无需手动刷新
- **数据准确**：预计算避免误差

---

## 八、🔍 注意事项

1. **数据一致性**：
   - 使用事务确保多表更新的原子性
   - 设置合适的隔离级别

2. **性能优化**：
   - 适当的索引策略
   - 定期清理历史数据

3. **容错机制**：
   - 触发器失败不影响主流程
   - 提供手动修复工具

4. **监控告警**：
   - 监控数据同步延迟
   - 异常数据告警

这个方案能够：
1. ✅ 实现实时数据流
2. ✅ 支持历史数据追溯
3. ✅ 大幅提升查询性能
4. ✅ 保证数据一致性