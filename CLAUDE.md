# 项目规范和要求

## 语言偏好
- 用户是中文用户，所有交流使用中文
- 深度思考（thinking）也使用中文
- **默认使用深度思考模式（小U）**：正常沟通时自动启用
- 分析时必须说明：
  - 优点和好处
  - 风险点和潜在问题
  - 具体建议

## 代码规范
- **必须**：每次修改代码后自动运行检查
  - JavaScript/TypeScript 文件：运行 `npm run lint`
  - 使用 `mcp__ide__getDiagnostics` 检查代码错误
  - 如果有测试，运行相关测试：`npm test`
- 修改代码前先理解现有代码风格，保持一致
- 不要添加不必要的注释
- **运行代码前必须说明**：
  - 用中文清楚说明这段代码要做什么
  - 说明预期的结果
  - 让用户能判断是否执行

## 打包和部署前必须检查
- **打包前必须执行（按顺序）**：
  1. `npm run lint` - 检查代码规范
  2. `npm run typecheck` - 检查类型错误（如果有）
  3. `npm test` - 运行所有测试
  4. 确认以上全部通过
  5. 才能执行 `npm run build`
- **部署前必须**：
  1. 本地构建成功
  2. 测试环境验证
  3. 获得用户明确批准
  4. 才能部署到生产环境

## 部署规范
- **严格禁止**：自动部署到生产环境
- **必须**：任何部署操作前都要明确询问用户确认
- 不能执行以下命令除非用户明确同意：
  - `git push` 到 main/master 分支
  - `npm publish`
  - 部署到生产数据库
  - 任何涉及线上环境的操作

## 数据库查询规范
- **查询操作不需要授权**（直接执行）：
  - SELECT 查询可以直接执行
  - 查看表结构可以直接执行（\d 表名）
  - 统计分析可以直接执行
  - 检查字段、索引、约束等
- **修改操作必须授权**：
  - INSERT/UPDATE/DELETE 必须征得同意
  - CREATE/DROP/ALTER 必须征得同意
  - 任何写入操作都要先确认
- **查询后告知结果**：
  - 直接执行查询
  - 报告查询结果
  - 不要每次都问是否可以查询
- **典型场景**：
  - "让我检查表结构" → 直接查，不用问
  - "看看有什么字段" → 直接查，不用问
  - "统计一下数据" → 直接查，不用问

## Git提交前检查清单（必须执行）
1. **查看待提交文件**：`git status`
2. **检查敏感信息**：
   - API密钥、token
   - 数据库密码
   - Supabase URL和密钥
   - 个人信息
3. **查看具体内容**：`git diff --cached`
4. **特别注意**：
   - `.md` 文档文件
   - 配置文件
   - 测试文件
5. **确认无敏感信息后才能提交**

## 快捷方式
- 小C = `ccusage` 查看 Claude Code 使用记录
- 小U = 深度思考模式
- 小I = `init` 初始化项目
- 小D = `--dangerously-skip-permission` 危险模式
- 小R = 读取 CLAUDE.md 查看所有规范
- 小多 = 两种模式：
  - **模式1**：运行 `node auto-run-tasks.js` 执行预设任务列表（10个并发）
  - **模式2**：并行多Agent任务（自动调度10个Agent同时工作）

## npm脚本执行规范
- **直接执行不询问**：看到 `npm run` 相关需求时，直接执行 `npm run` 查看脚本
- **必须提供脚本名**：每次让用户运行脚本时，必须明确告诉用户脚本名字
- **标准格式**：`npm run 脚本名` 或 `npm 脚本名`
- **例子**：
  - ❌ 错误："运行构建脚本"
  - ✅ 正确："运行 `npm run build`"

## 项目信息

### 项目概述
- **项目名称**：知行财库系统（zhixing-react-app）
- **项目类型**：全栈销售管理系统
- **部署地址**：https://zhixing-seven.vercel.app
- **主要功能**：销售管理、订单管理、佣金分配、多级销售体系
- **时区设置**：**中国标准时间 (UTC+8)**
  - 所有时间显示使用北京时间
  - 数据库时间戳转换为 Asia/Shanghai
  - 统计数据按中国时间计算（今天=北京时间0点到24点）

### 🆕 产品体系更新（2025年9月1日起）

#### 产品分类
1. **推币策略**（原指标系统）：现有产品，维持原功能
2. **推币系统**：Discord平台新产品，3天免费试用
3. **推股系统**：Discord平台新产品，3天免费试用

#### 定价方案

**推币策略（9月1日起新价，老用户续费也按新价）**：
- 月费：199u（原188u）
- 季度：588u
- 半年：1088u
- 一年：1888u

**推币系统/推股系统（Discord版）**：
- 月费：588u
- 季度：1688u
- 半年：2688u
- 一年：3888u
- 试用期：3天免费，到期自动移除权限

**组合套餐（推币/推股 + 推币策略）**：
- 月费：688u（节省99u）
- 季度：1988u
- 半年：2988u
- 一年：4588u

#### Discord集成要求
- 购买时需提供Discord账号
- 试用期3天，到期自动移除频道权限
- 需要续费提醒机制
- 相关文档：DISCORD_TRIAL_INTEGRATION.md

#### 订单拒绝原因扩展
新增两类拒绝原因：
1. **账号错误无法配置**：Discord账号无效、被封禁等
2. **测试期到期请购买**：3天试用期结束未续费

#### 微信通知系统
- 使用Server酱（sc.ftqq.com）发送通知
- 通知时机：订单被拒绝时
- 通知内容：销售员微信、客户微信、拒绝原因
- **通知对象**：销售员和客户双方都要收到通知

##### Server酱实现方案
1. **注册获取SendKey**
   - 访问 https://sct.ftqq.com/
   - GitHub账号登录并绑定微信
   - 获取SendKey存入环境变量

2. **通知发送流程**
   ```javascript
   // 订单拒绝时同时通知销售和客户
   async function sendRejectionNotification(order, reason) {
     // 1. 通知销售员
     await sendToServerChan({
       sendKey: salesSendKeys[order.sales_code],
       title: '订单拒绝通知',
       content: `客户${order.customer_wechat}的订单被拒绝，原因：${reason}`
     });
     
     // 2. 通知客户
     await sendToServerChan({
       sendKey: customerSendKeys[order.customer_wechat],
       title: '订单处理通知',
       content: `您的订单处理结果：${reason}，请联系销售员${order.sales_wechat}`
     });
   }
   ```

3. **多人通知方案**
   - 方案A：每个用户独立SendKey（需要用户先绑定）
   - 方案B：使用PushPlus支持群发（每天200条免费）
   - 方案C：企业微信机器人（需要企业微信）

4. **配置要求**
   - SendKey存储在环境变量
   - 添加通知日志表记录发送历史
   - 失败重试机制（最多3次）
   - 每日限额监控（免费版5条/天）

#### 数据库扩展字段
- `product_type`：产品类型（推币策略/推币系统/推股系统）
- `package_type`：套餐类型（单品/组合）
- `discord_id`：Discord账号
- `trial_end_time`：试用到期时间
- `rejection_reason`：拒绝原因（扩展选项）

#### 佣金计算
- **不变**：所有产品佣金计算逻辑保持不变
- 仍按：销售产出 × 销售佣金率

### 技术栈
**前端**：
- React 18.2.0 + Ant Design 5.12.8
- Redux Toolkit (状态管理)
- React Router Dom (路由)
- Axios (HTTP请求)

**后端/数据库**：
- Supabase (BaaS平台)
- PostgreSQL (数据库)
- 实时订阅功能

**部署**：
- Vercel (前端部署)
- Supabase Cloud (数据库托管)

### 项目结构
```
/Users/zzj/Documents/w/
├── client/              # React前端应用
│   ├── src/
│   │   ├── components/  # 组件（admin/common）
│   │   ├── pages/       # 页面组件
│   │   ├── services/    # API服务层
│   │   ├── store/       # Redux状态管理
│   │   └── utils/       # 工具函数
│   └── build/           # 构建输出
├── database/            # 数据库SQL文件
└── deployment/          # 部署配置
```

### 核心业务模块
1. **销售管理** (`SalesPage.js`)
   - 销售员注册与管理
   - 收款方式配置
   - 推广链接生成

2. **购买流程** (`PurchasePage.js`)
   - 订单创建
   - 支付方式选择（支付宝/加密货币）
   - 支付凭证上传

3. **管理后台** (`AdminDashboardPage.js`)
   - 订单审核 (`AdminOrders.js`)
   - 销售管理 (`AdminSales.js`)  
   - 财务管理 (`AdminFinance.js`)
   - 客户管理 (`AdminCustomers.js`)
   - 数据统计 (`AdminOverview.js`)

### 数据库主要表
- `sales_optimized` - 销售员信息与佣金配置
- `orders_optimized` - 订单信息与状态
- `customers_optimized` - 客户信息
- `admins` - 管理员账户
- `commission_history` - 佣金历史记录
- `system_config` - 系统配置

### 重要文件路径
- **前端入口**: `/client/src/index.js`
- **路由配置**: `/client/src/App.js`
- **API服务**: `/client/src/services/api.js`
- **Supabase配置**: `/client/src/services/supabase.js`
- **部署配置**: `/vercel.json`

### 环境变量
- `REACT_APP_SUPABASE_URL` - Supabase项目URL
- `REACT_APP_SUPABASE_ANON_KEY` - Supabase匿名密钥

### 常用命令
```bash
cd client
npm install          # 安装依赖
npm start           # 启动开发服务器
npm run build       # 构建生产版本
npm run lint        # 代码检查
npm test           # 运行测试
```

## 工作流程
1. 理解需求
2. **先查历史成功案例**
3. 查看相关代码
4. 修改代码
5. **自动运行 lint 和测试**
6. 确认无误后提交

## Agent调度流程（重要！每次必须执行）
**接到任务后的标准流程**：

### 快捷触发："小多"
当用户说"小多"时，根据上下文选择模式：

**模式1 - 运行预设任务**：
- 用户："小多" 或 "小多，运行任务"
- 我：执行 `node auto-run-tasks.js` 运行任务列表
- 适用：有固定任务列表需要批量执行

**模式2 - 并行Agent调度**：
- 用户："小多，检查代码" 或 "小多，优化性能"
- 我：调度5个Agent并行处理
- 适用：需要多个Agent协同工作

**判断逻辑**：
- 没有具体任务 → 运行 auto-run-tasks.js
- 有具体任务 → 启动Agent并行模式

### 第一步：分析并提出Agent调度方案
1. **理解任务需求**
   - 分析任务类型和复杂度
   - 识别需要的专业能力
   
2. **制定Agent调度方案**（必须包含）：
   ```
   📋 **Agent调度方案**
   
   任务分析：[简述任务目标]
   
   建议使用的Agents：
   1. agent-name - 负责：[具体职责]
   2. agent-name - 负责：[具体职责]
   
   执行顺序：
   - 步骤1：使用XX agent做YY
   - 步骤2：使用ZZ agent做AA
   
   ❓ 请确认方案或补充需要的Agent
   ```

3. **等待用户确认**
   - 用户确认 → 执行
   - 用户补充 → 调整方案
   - 用户修改 → 重新规划

### 第二步：执行已确认的方案
- 按照确认的方案调用相应Agent
- 实时汇报执行进度
- 完成后总结结果

### 示例场景：
- **代码优化任务** → code-reviewer + performance-engineer
- **API文档** → api-documenter + reference-builder  
- **安全审计** → security-auditor + code-reviewer
- **部署任务** → deployment-engineer + test-automator
- **数据库优化** → database-optimizer + sql-pro
- **前端开发** → frontend-developer + ui-ux-designer

## MCP工具使用原则
- **必须主动使用MCP工具**：
  - 有 `mcp__ide__getDiagnostics` 就自己检查代码错误
  - 有 `mcp__ide__executeCode` 就自己运行代码测试
  - 不要让用户手动做MCP能做的事
- **使用时说明目的**：
  - 告诉用户要实现什么目的
  - 执行后告诉用户结果
  - 不要让用户去浏览器控制台看

## MCP自动回测流程（架构重构后必执行）
- **回测时机**：完成架构重构后，修复页面Bug前
- **回测范围**：
  - 使用 `mcp__ide__executeCode` 测试产品配置API
  - 验证数据库架构改动的兼容性
  - 测试订单创建全流程
  - 验证免费试用逻辑
  - 检查价格计算准确性
- **回测通过标准**：
  - 所有API返回正确数据
  - 产品选择器动态加载成功
  - 免费试用和付费逻辑正确
  - 现有功能无回归问题
- **Bug修复流程**：回测发现问题 → 立即修复 → 再次回测 → 通过后继续

## Task工具使用原则
- **自动使用Task不需确认的场景**：
  - 检查前端页面显示
  - 搜索代码中的问题
  - 分析文件结构
  - 验证功能是否正常
- **只需告知结果**：
  - 直接运行Task工具
  - 完成后报告发现的问题
  - 不要每次都询问是否运行

## 测试页面规范
- **调整完页面后的处理**：
  - ❌ **错误**：给用户发送链接让用户自己打开
  - ✅ **正确**：使用 MCP 工具直接打开页面
  - 具体操作：调整好页面后，直接用 `open` 命令或相关 MCP 工具打开浏览器显示页面
- **自动化测试流程**：
  1. 完成页面调整
  2. 启动本地服务器（如需要）
  3. 使用 MCP 直接打开页面
  4. 不要让用户手动操作
- **打开无痕窗口**（推荐，避免缓存问题）：
  ```bash
  # Chrome 无痕模式
  open -a "Google Chrome" --args --incognito http://localhost:3000/admin/dashboard
  
  # Safari 隐私浏览
  open -a "Safari" --args --private http://localhost:3000/admin/dashboard
  
  # Firefox 隐私窗口
  open -a "Firefox" --args --private-window http://localhost:3000/admin/dashboard
  
  # Edge 无痕模式
  open -a "Microsoft Edge" --args --inprivate http://localhost:3000/admin/dashboard
  ```
- **优先使用无痕模式的原因**：
  - 避免缓存干扰测试
  - 确保看到最新的页面更改
  - 避免登录状态冲突
  - 更准确的测试结果

## 核心原则：先查历史，再做决定
**遇到任何问题，第一反应必须是**：
1. 🔍 **查找历史成功案例**
   - API调用失败 → 查之前成功的API调用
   - 数据库操作失败 → 查之前成功的数据库操作
   - 部署失败 → 查之前成功的部署记录
   - 配置错误 → 查之前正确的配置

2. 📂 **查找位置**：
   - 项目中的现有代码（最可靠）
   - 历史提交记录
   - 已有的配置文件
   - 成功运行的脚本

3. ✅ **复用成功模式**：
   - 找到了 → 直接复用
   - 没找到 → 才尝试新方法

**示例**：
- 问题：Supabase连接失败
- ❌ 错误：尝试各种新的连接方式
- ✅ 正确：直接看 `/client/src/services/supabase.js` 怎么连的，照抄

## 用户操作限制
- **用户只会点击运行按钮**
- **不会输入命令或修改代码**
- **必须提供完整的可执行脚本**：
  - 包含所有必要的配置
  - 处理所有错误情况
  - 输出清晰的执行结果
  - 脚本命名：`run-[功能名].js` 或 `run-[功能名].sh`
- **示例**：
  - ❌ 错误：让用户运行 `npm install && npm run build`
  - ✅ 正确：创建 `run-deploy.sh` 脚本，用户只需点击运行

## 问题排查原则
- **绝对禁止**：基于猜测或"可能"做判断
- **绝对禁止**：使用"大概"、"应该"、"可能"等不确定词汇
- **必须**：查到问题的根本原因
- **必须**：提供确凿的证据（具体代码、日志、错误信息）
- **必须**：在没有找到确切原因前，停止所有操作
- **必须有记忆**：
  - 之前成功的操作，要记住并复用
  - 遇到相同问题，先查看之前是如何解决的
  - 使用 Grep 搜索历史文件中的成功案例
- 排查步骤：
  1. **先查历史**：搜索之前成功的方法
  2. 收集所有相关信息
  3. 逐一验证每个可能性
  4. 找到确切证据
  5. 确认根本原因
  6. 才能提出解决方案

## 状态报告原则
- **必须明确说明现状**：
  - 执行了什么操作
  - 得到了什么结果
  - 通过什么方式验证
- **部署确认必须包含**：
  - 部署命令的执行结果
  - 线上环境的验证方式（如：查看部署日志、访问线上URL、检查版本号）
  - 具体的验证结果
- **示例**：
  - ❌ 错误："部署成功了"
  - ✅ 正确："执行了 git push，返回成功。但通过查看 Vercel 部署记录，没有新的部署。原因是..."

## 错题本（必须严格避免）
### 已犯过的错误：
1. **说"部署成功"却没有验证**
   - 错误：基于命令执行就说成功
   - 正确：必须查看部署平台日志、访问线上URL、确认版本更新
   
2. **基于猜测做判断**
   - 错误：文件找不到就说"还没更新"
   - 正确：先确认文件路径、部署状态、构建结果
   
3. **验证方法不完整**
   - 错误：只用一种方式验证
   - 正确：多方位验证（日志+URL+版本号+代码对比）

### 反思机制：
- 每次遇到类似场景，必须回顾错题本
- 不能重复同样的错误
- 新错误必须立即记录

4. **让用户手动输入命令**
   - 错误：告诉用户"运行 npm install"
   - 正确：创建 run-install.sh 脚本供用户点击

5. **发现错误就直接删除**
   - 错误：看到"引入了不存在的文件"就直接删除引用
   - 正确步骤：
     1. 先验证文件是否真的不存在（用 ls 或 Read）
     2. 查看为什么会引入这个文件（git log/blame）
     3. 确认是否应该创建文件而不是删除引用
     4. 评估删除的影响
     5. 最后才决定处理方案

6. **打包前不做完整检查**
   - 错误：直接打包，出错了才解决
   - 正确：打包前必须运行 lint、类型检查、测试

7. **搞混数据库表名**（已犯2次）
   - 错误：混淆 orders 和 orders_optimized 表
   - 正确：
     - **生产环境使用**：`orders_optimized`、`sales_optimized`、`customers_optimized`
     - **已废弃**：`orders`、`sales`、`customers`（旧表，不要使用）
   - 必须：每次操作前确认使用的是 `_optimized` 后缀的表

8. **提交代码包含敏感信息**（严重错误！）
   - 错误：直接提交，被GitHub检测到秘密信息
   - 正确流程（提交前必须）：
     1. `git status` 查看所有待提交文件
     2. 逐个检查是否包含：API密钥、密码、token、私人信息
     3. 使用 `git diff --cached` 查看具体内容
     4. 确认无敏感信息后才提交
   - 特别注意：文档文件很容易包含敏感信息

9. **不利用历史经验**
   - 错误：数据库连接失败，重新尝试各种方法
   - 正确：
     1. 先搜索项目中成功连接的代码（`grep -r "supabase.from"` ）
     2. 查看之前成功的配置文件
     3. 复用已验证的方法
   - 必须：建立"成功案例库"的思维

10. **说做好了但没验证**
   - 错误：写了触发器就说"处理好了"，实际没设置所需字段
   - 正确：
     1. 写完代码后立即验证
     2. 确认实际效果符合预期
     3. 不能只看代码，要看结果
   - 必须：实际验证，不能仅凭代码判断

11. **未经同意修改代码**
   - 错误：自作主张修改页面或功能
   - 正确：
     1. 任何修改前必须告知用户
     2. 说明要改什么、为什么改
     3. 得到明确同意才能改
   - 必须：不能偷偷改任何东西

12. **改完代码不自己验证**（严重！已犯多次）
   - 错误：改了代码就让用户去验证
   - 正确：
     1. 改完代码自己先测试
     2. 确认功能正常再告诉用户
     3. 发现问题自己先修复
   - 必须：自己的代码自己先验证

13. **改数据库不验证关联影响**
   - 错误：改了数据库字段（如'7days'改成'7天'）不检查代码兼容性
   - 正确：
     1. 改数据库前先搜索所有使用该字段的代码
     2. 确保代码和数据库值匹配
     3. 验证所有相关功能
   - 案例：数据库存'7天'，代码判断'7days'，导致免费订单功能失效

14. **用"可能"分析错误**（又犯了！）
   - 错误：看到错误说"可能是重复提交"
   - 正确：
     1. 查具体的错误日志
     2. 复现问题找根本原因
     3. 提供确凿的原因，不是猜测
   - 必须：错误必须查清楚，不能用"可能"

15. **拖延解决问题**
   - 错误：发现问题说"稍后处理"、"留着过年"
   - 正确：
     1. 发现问题立即修复
     2. 不拖延，不找借口
     3. 用户遇到问题就是最高优先级
   - 必须：问题不过夜，立即解决

16. **分析问题不彻底解决**（重大态度问题！）
   - 错误：找到了错误原因，分析了触发条件，但不立即修复
   - 正确：
     1. 找到问题 = 立即修复
     2. 分析完成 = 马上动手
     3. 不能只分析不解决
   - 必须：发现问题必须一次性彻底解决完

17. **不理解任务重点**
   - 错误：用户要我记录问题和写README，我去解决单个技术问题
   - 正确：
     1. 明确用户的真实需求
     2. 专注于要求的任务（记录+文档）
     3. 不要偏离主要目标
   - 必须：理解任务优先级，做用户真正需要的事

18. **临时绕过不是根本解决**
   - 错误：用临时方法（如跳过序列）糊弄，说"修好了"
   - 问题：用户遇到序列问题怎么办？让用户重试？
   - 正确：
     1. 找出序列问题的根本原因
     2. 彻底解决，不是绕过
     3. 确保用户体验流畅
   - 必须：根本解决，不能用临时绕过糊弄

19. **未经允许在生产数据库写测试数据**（极其严重！）
   - 错误：在线上系统创建"张三"、"李四"等测试销售和订单
   - 危险：
     1. 污染生产数据
     2. 影响真实统计
     3. 可能被用户看到
     4. 破坏数据完整性
   - 正确：
     1. 绝不在生产环境写测试数据
     2. 使用本地或测试环境
     3. 任何数据库操作都要征得同意
   - 必须：生产数据库神圣不可侵犯

20. **出现编译错误不先自己用MCP检查**（刚刚又犯！）
   - 错误：看到错误就直接告诉用户，让用户去看
   - 正确：
     1. 先用 `mcp__ide__getDiagnostics` 检查错误
     2. 自己分析错误原因
     3. 自己修复问题
     4. 验证修复成功后再告诉用户
   - 必须：自己的错误自己先解决，不要丢给用户

21. **给线上链接让用户测试**（极其愚蠢！刚犯！）
   - 错误：让用户去 https://zhixing-seven.vercel.app 测试
   - 正确：
     1. 本地测试用 http://localhost:3000
     2. 启动本地服务器
     3. 在本地环境测试和调试
     4. 测试完成后才部署到线上
   - 必须：开发在本地，不要让用户去生产环境调试！

22. **改完功能不自己检查**（又犯了！极其严重！）
   - 错误：改完代码就让用户去检查
   - 案例：
     1. 订单金额选项不对（1977、397？）
     2. 销售人员显示代码而不是微信号
     3. 搜索框不好用
     4. 订单状态都是"待配置"
     5. 客户微信显示"-"
   - 正确：
     1. 改完代码自己先全面测试
     2. 检查每个功能是否正常
     3. 验证数据显示是否正确
     4. 确认没问题才告诉用户
   - 必须：自己的代码自己负责到底！

23. **给错误的页面链接**（刚犯！）
   - 错误：说二级销售对账是 /admin/sales-reconciliation
   - 正确：
     1. 二级销售对账：/sales/secondary（或实际路径）
     2. 给链接前先确认路由
     3. 不能凭记忆瞎说
   - 必须：给链接前必须查证！

24. **Git推送但没添加文件**（又犯了！极其严重！）
   - 错误：直接 git push 但文件还在 untracked 状态
   - 案例：AdminCustomersOptimized.js 没加就推了
   - 正确：
     1. git status 查看所有文件状态
     2. git add 添加需要的文件
     3. git commit 提交
     4. git push 推送
   - 必须：推送前必须检查所有相关文件都已添加！

25. **不主动用MCP验证**（又犯！）
   - 错误：让用户自己在浏览器执行验证脚本
   - 正确：
     1. 修复完成后自动用MCP验证
     2. 确认功能正常后再告诉用户
     3. 不要让用户手动验证
   - 必须：自己用MCP工具验证结果！

## 注意事项
- 保护用户数据安全
- 不泄露敏感信息（API密钥、密码等）
- 重要操作前先备份
- 遵循最佳实践

## 📊 数据库查询优化修复记录（2025-09-07）

### 问题背景
用户报告管理后台多个页面超时：
- 数据概览、资金统计、订单管理、销售管理：`canceling statement due to statement timeout`
- Top5销售排行榜、销售层级统计、转化率统计：显示无数据或不稳定

### 根源分析
发现5个关键全表查询导致数据库超时：
1. **api.js:1606** - `getStats()` 中的 `SELECT * FROM orders_optimized` 无LIMIT
2. **api.js:2181** - `getStatsRealtime()` 中的全表查询
3. **supabase.js:1009** - `getOrders()` 中的 `SELECT * FROM orders_optimized` 无LIMIT  
4. **api.js:830** - `getSales()` 中的 `SELECT * FROM sales_optimized` 无LIMIT
5. **api.js:2611** - `getSalesConversionStats()` 中的 `SELECT * FROM sales_optimized` 无LIMIT

### 修复措施
**已修复的查询优化**：
1. **数据概览查询** - 添加字段筛选 + `.limit(5000)` + 排序
2. **实时统计查询** - 重定向到主查询，避免重复全表扫描
3. **订单管理查询** - 添加 `.limit(1000)`，显示最新1000条订单
4. **销售管理查询** - 添加 `.limit(500)` + 按金额排序
5. **转化率统计查询** - 字段优化 + `.limit(200)` + 排序

**性能提升**：
- 数据传输量：从无限制 → 限制在5000行以内
- 查询字段：从 `SELECT *` → 选择必要字段（部分查询）
- 查询时间：从10-30秒超时 → 2-5秒完成
- 内存占用：大幅减少数据处理量

### 修复结果
- ✅ **转化率统计**：修复成功，稳定显示数据
- ❌ **Top5销售排行榜**：显示无数据（数据问题，非查询问题）
- ❌ **销售层级统计**：显示无数据（数据问题，非查询问题）

### 数据问题分析
经验证发现：
- 数据库 `sales_optimized` 表中大部分销售的 `total_amount` 和 `total_orders` 为0
- 只有少数销售（如'fl261247'有1588金额）有实际业绩数据
- Top5排行榜按金额排序时，0数据无排序意义，故显示空白
- **结论**：显示"无数据"反映真实业务状态，不是技术问题

### 错误分析记录
**分析错误**：错误判断数据问题原因
- 错误结论：认为"大部分销售金额为0"导致无数据显示
- 实际情况：用户确认转化率统计已有数据，说明修复有效
- 正确做法：应该先验证修复效果再下结论

### 技术改进
- 查询性能显著提升，解决超时问题
- 保持数据完整性，不影响业务逻辑  
- 为后续数据增长预留性能空间

## 🎨 客户管理多产品合并显示方案（用户已确认）

### 设计目标
将同一客户购买的多个产品合并在一行显示，提供更清晰的客户价值视图。

### 显示效果
```
客户信息 | 购买产品 | 总金额 | 销售员 | 订单状态 | 最新订单时间
customer1 | [推币策略][推币系统][组合套餐] | $2,252 | 张销售 | 活跃中 | 2025-09-05 14:30
         | 详细: 策略$588 + 系统$588 + 组合$1,076 |
```

### 核心优势
1. **一行显示客户全貌**：清楚展示客户总价值
2. **产品标签直观**：不同产品类型用颜色区分
3. **状态智能合并**：活跃中 > 部分过期 > 全部过期
4. **表格更简洁**：减少重复信息，查找方便

### 实现要点
- **数据聚合**：按 customer_wechat 分组合并订单
- **产品标签**：推币策略（蓝色）、推币系统（绿色）、组合套餐（橙色）
- **金额计算**：显示总金额，hover 显示各产品明细
- **排序规则**：按总金额降序，便于识别高价值客户
- **状态逻辑**：
  - 活跃中：至少一个产品未过期
  - 部分过期：部分产品过期
  - 全部过期：所有产品都过期

### 对比优势
- **原方案**：customer1 分3行显示，信息重复，不易查看总价值
- **新方案**：customer1 合并1行，总价值$2,252 一目了然

## 📊 项目完整数据架构

### 一、数据库表结构（8个核心表）

#### 1. orders_optimized（订单表）
- **主键**: order_id
- **核心字段**: customer_wechat, sales_code, amount, duration, status
- **计算字段**: commission_amount = amount * commission_rate
- **时间字段**: created_at, payment_time, config_time, expiry_time
- **关联**: sales_code → sales_optimized (多对一)

#### 2. sales_optimized（销售员表）  
- **主键**: id, **唯一**: sales_code
- **核心字段**: wechat_name, sales_type, commission_rate
- **层级字段**: parent_sales_code, primary_sales_code
- **统计字段**: pending_commission, total_commission
- **关联**: parent_sales_code → 自关联

#### 3. customers_optimized（客户表）
- **主键**: id, **唯一**: customer_wechat
- **统计字段**: total_orders, total_amount
- **催单字段**: is_reminded, reminder_time
- **关联**: customer_wechat → orders (一对多)

#### 4. admins（管理员表）
- **字段**: username, password(bcrypt), role

#### 5. commission_history（佣金历史）
- **记录**: 佣金率变更历史

#### 6. excluded_sales_config（排除配置）
- **功能**: 排除特定销售不计入统计

#### 7. overview_stats（统计概览）
- **更新**: 每日凌晨统计前一天数据

#### 8. system_config（系统配置）
- **存储**: 全局配置参数

### 二、页面路由映射（13个页面）

#### 前台页面
- `/` - 首页导航
- `/sales` - 销售管理（注册、配置收款、生成链接）
- `/purchase?sales_code=XXX` - 购买页面

#### 管理后台
- `/admin` - 管理员登录
- `/admin/dashboard` - 后台首页
- `/admin/orders` - 订单管理（审核、配置）
- `/admin/sales` - 销售管理（佣金调整）
- `/admin/finance` - 财务管理（佣金支付）
- `/admin/customers` - 客户管理（催单功能）
- `/admin/overview` - 数据概览（统计图表）

#### 对账页面
- `/sales/commission` - 一级销售对账
- `/sales/secondary` - 二级销售对账

### 三、核心API接口（10+个）

#### 管理API
- `AdminAPI.getStats` - 获取统计数据
- `AdminAPI.getOrders` - 获取订单列表
- `AdminAPI.updateOrderStatus` - 更新订单状态（触发佣金计算）
- `AdminAPI.getSales` - 获取销售列表
- `AdminAPI.getCustomers` - 获取客户列表
- `AdminAPI.markReminder` - 标记催单
- `AdminAPI.getPrimarySalesStats` - 一级销售统计
- `AdminAPI.getConversionStats` - 转化率统计

#### 销售API
- `salesAPI.register` - 注册销售员
- `salesAPI.getSalesByWechat` - 查询销售信息

#### 订单API
- `ordersAPI.createOrder` - 创建订单

### 四、数据流转关系

#### 订单流程
```
创建(pending) → 审核 → 支付(confirmed_payment) → 配置(confirmed_config) → 激活(active) → 到期(expired)
```

#### 佣金计算
```
直销佣金 = 订单金额 × 销售佣金率
团队佣金 = 订单金额 × (上级率 - 下级率)
待返佣金 = SUM(未支付订单佣金)
```

#### 催单规则
- 付费订单：到期前7天内
- 免费订单：到期前3天内
- 已过期：30天内仍显示

#### 转化率计算
```
转化率 = (付费订单数 / 总订单数) × 100%
```

### 五、时间周期

#### 时区设置
- 统一使用：中国标准时间 (UTC+8)
- 今日定义：北京时间 00:00-23:59

#### 更新机制
- **实时更新**: 订单状态、佣金计算
- **触发器更新**: 客户统计、销售统计
- **定时更新**: overview_stats（每日凌晨）

### 六、关键业务规则

1. **销售层级**: 最多二级分销
2. **佣金规则**: 上级率必须高于下级
3. **订单审核**: 必须人工确认
4. **催单限制**: 已催单不重复显示
5. **统计排除**: 可排除测试销售
6. **时间标准**: 全部使用北京时间

### 七、表关联关系

```
orders → sales (多对一，通过sales_code)
orders → customers (多对一，通过customer_wechat)
sales → sales (自关联，parent_sales_code)
customers ← orders (一对多)
```

**关系说明**：
- 多对一：多个订单对应一个销售员
- 一对多：一个客户可以有多个订单
- 自关联：销售员的上下级关系

## 🚨 当前线上Bug记录与修复方案（2024年9月6日）

### 紧急Bug清单

#### Bug #1: 数据概览页面崩溃 `r.map is not a function`
**错误位置**：AdminOverview.js 第677行
**根本原因**：`sales`变量在某些情况下不是数组，但代码直接调用`.map()`
**修复方案**：
```javascript
// 修改前
{Array.isArray(sales) && sales.map(sale => (
// 修改后  
{sales && Array.isArray(sales) && sales.map(sale => (
```

#### Bug #2: 订单管理页面无法切换
**根本原因**：React错误边界机制触发，整个管理后台组件崩溃
**修复方案**：添加错误边界组件包装AdminOrders

#### Bug #3: 销售信息显示逻辑错误（二级销售显示为独立销售）
**问题现象**：有"一级销售微信"的订单（说明是二级销售），但"销售信息"列显示为"独立销售"
**根本原因**：两个列使用了不同的层级关系判断逻辑，导致显示不一致
- "一级销售微信"列：使用 `record.secondary_sales?.primary_sales_id` 判断
- "销售信息"列：使用复杂的多字段OR逻辑判断，可能判断失效
**修复方案**：
```javascript
// 统一两列的判断逻辑，都使用相同的标准
if (record.secondary_sales?.primary_sales_id) {
  salesType = '二级销售';  // 有上级
} else {
  salesType = '独立销售'; // 无上级
}
```

#### Bug #4: 生效时间数据不一致
**问题现象**：`effective_time`字段有些订单有数据，有些没有
**修复方案**：
```sql
-- 修复历史数据
UPDATE orders_optimized 
SET effective_time = COALESCE(payment_time, created_at)
WHERE status IN ('confirmed_config', 'active') AND effective_time IS NULL;

-- 添加触发器确保一致性
CREATE OR REPLACE FUNCTION set_effective_time()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'confirmed_config' AND NEW.effective_time IS NULL THEN
    NEW.effective_time = NOW();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### Bug #5: 一级销售统计数据错误
**问题现象**：总订单数 ≠ 直销订单 + 团队订单
**根本原因**：统计查询逻辑存在重复计算或遗漏
**修复方案**：重新设计统计查询SQL，确保数据准确性

### Bug修复优先级
1. **最高优先级**：数据概览页面崩溃（影响管理员使用）
2. **高优先级**：订单管理页面无法切换（核心业务功能）
3. **中优先级**：统计数据错误（影响决策准确性）
4. **一般优先级**：显示逻辑错误、数据不一致

## 🆕 产品体系升级方案（2024年9月6日实施）

### 升级决策确认
- ✅ **价格生效时间**：9月6日 00:00（北京时间）
- ✅ **金额筛选器**：新旧价格都保留，只显示金额
- ✅ **套餐半年价格**：3188u
- ✅ **Discord字段**：现在就加discord_id字段
- ✅ **历史订单**：标记为"推币策略"，保持原金额显示
- ✅ **列插入位置**：订单管理在"一级销售微信"后插入"产品类型"，客户管理在"TradingView用户"后插入"主要产品"

### 新产品定价体系
1. **推币策略**（从188u涨价）：
   - 月费：288u、季度：588u、半年：1088u、年费：1888u

2. **推币系统**（Discord新产品）：
   - 月费：588u、季度：1588u、半年：2588u、年费：3999u

3. **套餐组合**（策略+系统）：
   - 月费：688u、季度：1888u、半年：3188u、年费：4688u

### 数据库改造方案
```sql
-- 备份数据库（必须先执行）
pg_dump zhixing_db > backup_upgrade_20240906.sql

-- 添加产品字段
ALTER TABLE orders_optimized 
ADD COLUMN product_type VARCHAR(20) DEFAULT '推币策略',
ADD COLUMN discord_id VARCHAR(50);

-- 历史数据标记
UPDATE orders_optimized 
SET product_type = '推币策略'
WHERE product_type IS NULL OR product_type = '';

-- 添加索引
CREATE INDEX idx_orders_product_type ON orders_optimized(product_type);
```

### 前端改造要点
1. **购买页面**：保持现有链接格式，内部增加产品选择
2. **订单管理**：在第4列插入"产品类型"，第8列插入"Discord账号"
3. **客户管理**：在第3列插入"主要产品"
4. **金额筛选器**：包含新旧所有价格选项，支持重复金额区分

### 兼容性保证
- 所有现有字段100%保留
- 现有销售链接继续有效
- 历史数据完整保护
- 现有功能零影响

### 实施顺序
1. **第一步**：修复所有线上Bug（必须优先）
2. **第二步**：数据库备份和字段添加
3. **第三步**：前端购买页面改造
4. **第四步**：管理后台列表扩展
5. **第五步**：全面测试验证
6. **第六步**：生产环境部署

### 验收标准
- [ ] 所有Bug彻底修复
- [ ] 三种产品可正常购买
- [ ] 管理后台新字段正确显示
- [ ] 历史数据完整无损
- [ ] 价格在9月6日正确切换

## 相关文档
- **详细升级方案**：`/兼容性产品升级方案_含Bug修复.md`
- **产品体系方案**：`/产品体系升级改造方案.md`
- **Bug修复记录**：本CLAUDE.md文档Bug记录部分