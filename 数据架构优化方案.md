# 📊 数据架构优化方案

## 一、当前数据流对比

### 1️⃣ 一级销售对账页面
- **数据源**: `SupabaseService.getPrimarySalesSettlement` 
- **特点**: 
  - ✅ 直接从数据库查询，数据准确
  - ✅ 计算逻辑清晰，包含动态佣金率
  - ✅ 已经稳定运行，用户认可
  - ✅ 包含完整的订单、二级销售、统计信息

### 2️⃣ 管理员后台销售页面  
- **数据源**: `AdminAPI.getSales`
- **问题**:
  - ❌ 合并多个表数据，导致重复
  - ❌ 前端计算复杂，容易不一致
  - ❌ 缓存策略混乱

## 二、优化方案（推荐）

### 方案A：统一使用后端计算（最佳）

```javascript
// 管理员页面也使用同样的数据源
AdminAPI.getSales = async (params) => {
  // 对于一级销售，直接调用 getPrimarySalesSettlement
  const primaryResults = await SupabaseService.getPrimarySalesSettlement(params);
  
  // 对于二级销售，调用 getSecondarySalesSettlement
  const secondaryResults = await SupabaseService.getSecondarySalesSettlement(params);
  
  // 合并结果，但标记来源
  return {
    primary: primaryResults,
    secondary: secondaryResults
  };
}
```

**优点**：
- 数据一致性100%保证
- 减少前端计算负担
- 便于维护

### 方案B：数据同步机制

```javascript
// 定期从一级销售对账页面同步数据到管理员后台
const DataSyncService = {
  async syncFromPrimarySettlement() {
    // 获取一级销售对账的数据
    const primaryData = await SupabaseService.getPrimarySalesSettlement();
    
    // 更新到管理员后台的缓存
    AdminCache.update('sales', primaryData);
    
    return primaryData;
  }
}
```

**优点**：
- 保持现有架构
- 逐步过渡

**缺点**：
- 可能有延迟
- 维护成本高

## 三、二级销售数据获取策略

### 当前问题
1. 二级销售可能独立存在（无一级销售关联）
2. 二级销售可能属于某个一级销售
3. 需要区分"独立销售"和"二级销售"

### 推荐方案

```javascript
// 二级销售数据获取优化
SupabaseService.getSecondarySalesData = async (params) => {
  // 1. 获取所有二级销售
  const { data: allSecondary } = await supabase
    .from('secondary_sales')
    .select('*');
  
  // 2. 分类处理
  const categorized = {
    independent: [],  // 独立销售（primary_sales_id = null）
    managed: []       // 有上级的二级销售
  };
  
  allSecondary.forEach(sale => {
    if (!sale.primary_sales_id) {
      categorized.independent.push({
        ...sale,
        sales_type: 'independent',
        display_type: '独立销售'
      });
    } else {
      categorized.managed.push({
        ...sale,
        sales_type: 'secondary',
        display_type: '二级销售'
      });
    }
  });
  
  // 3. 计算各自的佣金和统计
  return {
    ...categorized,
    total: allSecondary.length
  };
}
```

## 四、数据去重策略

### 1. 数据库层面
```sql
-- 添加唯一约束，防止重复
ALTER TABLE primary_sales ADD CONSTRAINT unique_wechat_primary UNIQUE (wechat_name);
ALTER TABLE secondary_sales ADD CONSTRAINT unique_wechat_secondary UNIQUE (wechat_name);
```

### 2. 应用层面
```javascript
// 显示时去重
const displaySales = (sales) => {
  const seen = new Set();
  return sales.filter(sale => {
    const key = `${sale.wechat_name}_${sale.sales_type}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}
```

## 五、实施步骤

### 第1步：清理重复数据
```sql
-- 查找并删除重复
DELETE FROM secondary_sales 
WHERE id NOT IN (
  SELECT MIN(id) 
  FROM secondary_sales 
  GROUP BY wechat_name
);
```

### 第2步：统一数据源
1. 修改 `AdminAPI.getSales` 使用 `getPrimarySalesSettlement`
2. 确保所有页面使用相同的数据服务

### 第3步：优化显示逻辑
1. 添加 `sales_type` 标识
2. 前端根据类型显示不同标签
3. 统一佣金率格式

### 第4步：测试验证
1. 对比各页面数据
2. 确认佣金计算正确
3. 验证更新功能

## 六、预期效果

✅ 所有页面数据100%一致
✅ 无重复记录
✅ 佣金率更新实时生效
✅ 清晰区分销售类型

## 七、风险控制

1. **备份数据**：操作前完整备份
2. **灰度发布**：先在测试环境验证
3. **监控告警**：添加数据异常监控
4. **回滚方案**：保留原代码分支
