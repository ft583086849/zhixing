# 📊 实时对账系统优化方案

> 创建时间：2025-08-15
> 修正：对账记录应该实时产生，而不是每日汇总

---

## 一、❌ 原设计的问题

之前的设计：
- 每个销售每天一条对账记录
- 需要等到当天结束才能看到对账数据
- 无法实时追踪每笔订单的佣金

**问题**：
- 不够实时
- 无法精确对账
- 销售看不到即时收益

---

## 二、✅ 正确的对账系统设计

### 1️⃣ sales_reconciliation表 - 销售对账明细表（重新设计）
```sql
CREATE TABLE sales_reconciliation (
  id SERIAL PRIMARY KEY,
  
  -- 对账记录号
  reconciliation_number VARCHAR(50) UNIQUE NOT NULL,  -- 对账流水号
  
  -- 订单信息
  order_id INTEGER NOT NULL,                        -- 订单ID
  order_number VARCHAR(50) NOT NULL,                -- 订单号
  order_amount DECIMAL(10,2) NOT NULL,              -- 订单金额
  order_type VARCHAR(20),                           -- free/paid/renewal
  order_duration VARCHAR(20),                       -- 7days/1month/3months/6months/1year
  
  -- 销售信息
  sales_id INTEGER NOT NULL,                        -- 销售ID
  sales_code VARCHAR(50) NOT NULL,                  -- 销售代码
  sales_wechat VARCHAR(100) NOT NULL,               -- 销售微信
  sales_type VARCHAR(20) NOT NULL,                  -- primary/secondary/independent
  sales_user_id INTEGER,                            -- 未来的用户ID
  
  -- 客户信息
  customer_id INTEGER,                              -- 客户ID
  customer_wechat VARCHAR(100),                     -- 客户微信
  customer_user_id INTEGER,                         -- 未来的用户ID
  
  -- 佣金计算
  commission_rate DECIMAL(5,4),                     -- 佣金率
  commission_amount DECIMAL(10,2) DEFAULT 0,        -- 佣金金额
  commission_type VARCHAR(20),                      -- direct/distribution/bonus
  
  -- 分销信息（如果涉及分销）
  is_distribution BOOLEAN DEFAULT false,            -- 是否是分销订单
  primary_sales_id INTEGER,                         -- 一级销售ID（如果是二级销售的订单）
  primary_sales_wechat VARCHAR(100),                -- 一级销售微信
  primary_commission_amount DECIMAL(10,2),          -- 一级销售分成
  secondary_sales_id INTEGER,                       -- 二级销售ID
  secondary_commission_amount DECIMAL(10,2),        -- 二级销售佣金
  
  -- 实时余额（关键字段！）
  balance_before DECIMAL(10,2) DEFAULT 0,           -- 交易前余额
  balance_after DECIMAL(10,2) DEFAULT 0,            -- 交易后余额
  
  -- 结算状态
  settlement_status VARCHAR(20) DEFAULT 'pending',   -- pending/confirmed/settled/paid
  confirmed_at TIMESTAMP,                           -- 确认时间
  settled_at TIMESTAMP,                             -- 结算时间
  paid_at TIMESTAMP,                                -- 支付时间
  payment_batch_id VARCHAR(50),                     -- 支付批次号
  
  -- 对账状态
  reconciliation_status VARCHAR(20) DEFAULT 'auto',  -- auto/manual/disputed/resolved
  dispute_reason TEXT,                              -- 争议原因
  dispute_resolved_at TIMESTAMP,                    -- 争议解决时间
  
  -- 备注
  remark TEXT,                                      -- 备注信息
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_recon_order ON sales_reconciliation(order_id);
CREATE INDEX idx_recon_sales ON sales_reconciliation(sales_id, created_at DESC);
CREATE INDEX idx_recon_status ON sales_reconciliation(settlement_status);
CREATE INDEX idx_recon_number ON sales_reconciliation(reconciliation_number);
```

### 2️⃣ sales_balance表 - 销售余额表（新增）
```sql
CREATE TABLE sales_balance (
  id SERIAL PRIMARY KEY,
  
  -- 销售信息
  sales_id INTEGER UNIQUE NOT NULL,                 -- 销售ID
  sales_code VARCHAR(50) UNIQUE NOT NULL,           -- 销售代码
  sales_wechat VARCHAR(100) NOT NULL,               -- 销售微信
  sales_type VARCHAR(20) NOT NULL,                  -- primary/secondary/independent
  sales_user_id INTEGER,                            -- 未来的用户ID
  
  -- 余额信息（核心）
  total_earned DECIMAL(10,2) DEFAULT 0,             -- 累计收入
  total_paid DECIMAL(10,2) DEFAULT 0,               -- 累计已支付
  current_balance DECIMAL(10,2) DEFAULT 0,          -- 当前余额（可提现）
  pending_amount DECIMAL(10,2) DEFAULT 0,           -- 待确认金额
  frozen_amount DECIMAL(10,2) DEFAULT 0,            -- 冻结金额（争议中）
  
  -- 统计信息
  total_orders INTEGER DEFAULT 0,                   -- 总订单数
  direct_orders INTEGER DEFAULT 0,                  -- 直销订单数
  distribution_orders INTEGER DEFAULT 0,            -- 分销订单数
  
  -- 本月统计（实时更新）
  month_earned DECIMAL(10,2) DEFAULT 0,             -- 本月收入
  month_orders INTEGER DEFAULT 0,                   -- 本月订单数
  
  -- 今日统计（实时更新）
  today_earned DECIMAL(10,2) DEFAULT 0,             -- 今日收入
  today_orders INTEGER DEFAULT 0,                   -- 今日订单数
  
  -- 最后结算信息
  last_settlement_date DATE,                        -- 最后结算日期
  last_settlement_amount DECIMAL(10,2),             -- 最后结算金额
  next_settlement_date DATE,                        -- 下次结算日期
  
  -- 支付信息
  payment_method VARCHAR(20),                       -- 默认支付方式
  payment_account VARCHAR(100),                     -- 支付账号
  
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_balance_sales ON sales_balance(sales_id);
CREATE INDEX idx_balance_code ON sales_balance(sales_code);
```

### 3️⃣ daily_reconciliation_summary表 - 每日对账汇总表（用于报表）
```sql
CREATE TABLE daily_reconciliation_summary (
  id SERIAL PRIMARY KEY,
  
  -- 汇总维度
  summary_date DATE NOT NULL,                       -- 汇总日期
  sales_id INTEGER NOT NULL,                        -- 销售ID
  sales_code VARCHAR(50) NOT NULL,                  -- 销售代码
  sales_type VARCHAR(20),                           -- 销售类型
  
  -- 订单汇总
  total_orders INTEGER DEFAULT 0,                   -- 当日总订单
  free_orders INTEGER DEFAULT 0,                    -- 免费订单数
  paid_orders INTEGER DEFAULT 0,                    -- 付费订单数
  renewal_orders INTEGER DEFAULT 0,                 -- 续费订单数
  
  -- 金额汇总
  total_revenue DECIMAL(10,2) DEFAULT 0,            -- 当日总销售额
  total_commission DECIMAL(10,2) DEFAULT 0,         -- 当日总佣金
  direct_commission DECIMAL(10,2) DEFAULT 0,        -- 直销佣金
  distribution_commission DECIMAL(10,2) DEFAULT 0,  -- 分销佣金
  
  -- 结算状态
  confirmed_amount DECIMAL(10,2) DEFAULT 0,         -- 已确认金额
  pending_amount DECIMAL(10,2) DEFAULT 0,           -- 待确认金额
  settled_amount DECIMAL(10,2) DEFAULT 0,           -- 已结算金额
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_daily_summary ON daily_reconciliation_summary(summary_date, sales_id);
```

---

## 三、🔄 实时数据流

### 1. 订单创建时立即生成对账记录
```sql
CREATE OR REPLACE FUNCTION create_reconciliation_record()
RETURNS TRIGGER AS $$
DECLARE
  v_sales_type VARCHAR(20);
  v_primary_commission DECIMAL(10,2);
  v_secondary_commission DECIMAL(10,2);
  v_current_balance DECIMAL(10,2);
BEGIN
  -- 获取销售类型
  SELECT sales_type INTO v_sales_type 
  FROM secondary_sales 
  WHERE sales_code = NEW.sales_code;
  
  -- 获取当前余额
  SELECT current_balance INTO v_current_balance
  FROM sales_balance
  WHERE sales_code = NEW.sales_code;
  
  IF v_current_balance IS NULL THEN
    v_current_balance := 0;
  END IF;
  
  -- 创建对账记录
  INSERT INTO sales_reconciliation (
    reconciliation_number,
    order_id,
    order_number,
    order_amount,
    sales_id,
    sales_code,
    sales_wechat,
    sales_type,
    customer_wechat,
    commission_rate,
    commission_amount,
    balance_before,
    balance_after,
    settlement_status
  )
  SELECT 
    'REC' || TO_CHAR(NOW(), 'YYYYMMDDHH24MISS') || NEW.id,
    NEW.id,
    NEW.order_number,
    NEW.amount,
    s.id,
    s.sales_code,
    s.wechat_name,
    s.sales_type,
    NEW.customer_wechat,
    NEW.commission_rate,
    NEW.commission_amount,
    v_current_balance,
    v_current_balance + NEW.commission_amount,
    'pending'
  FROM secondary_sales s
  WHERE s.sales_code = NEW.sales_code;
  
  -- 如果是二级销售的订单，也要给一级销售创建对账记录
  IF v_sales_type = 'secondary' THEN
    -- 计算分成
    v_secondary_commission := NEW.commission_amount;
    v_primary_commission := NEW.amount * 0.4 - v_secondary_commission;
    
    -- 为一级销售创建分销对账记录
    INSERT INTO sales_reconciliation (
      reconciliation_number,
      order_id,
      order_number,
      order_amount,
      sales_id,
      sales_code,
      sales_wechat,
      sales_type,
      commission_type,
      commission_amount,
      is_distribution,
      secondary_sales_id,
      secondary_commission_amount,
      settlement_status
    )
    SELECT 
      'REC' || TO_CHAR(NOW(), 'YYYYMMDDHH24MISS') || NEW.id || 'P',
      NEW.id,
      NEW.order_number,
      NEW.amount,
      ps.id,
      ps.sales_code,
      ps.wechat_name,
      'primary',
      'distribution',
      v_primary_commission,
      true,
      s.id,
      v_secondary_commission,
      'pending'
    FROM secondary_sales s
    JOIN secondary_sales ps ON s.primary_sales_id = ps.id
    WHERE s.sales_code = NEW.sales_code;
  END IF;
  
  -- 更新销售余额表
  INSERT INTO sales_balance (
    sales_id,
    sales_code,
    sales_wechat,
    sales_type,
    total_earned,
    current_balance,
    pending_amount,
    total_orders,
    month_earned,
    month_orders,
    today_earned,
    today_orders
  )
  SELECT 
    s.id,
    s.sales_code,
    s.wechat_name,
    s.sales_type,
    NEW.commission_amount,
    0,
    NEW.commission_amount,
    1,
    CASE WHEN DATE_TRUNC('month', NOW()) = DATE_TRUNC('month', NEW.created_at) 
         THEN NEW.commission_amount ELSE 0 END,
    CASE WHEN DATE_TRUNC('month', NOW()) = DATE_TRUNC('month', NEW.created_at) 
         THEN 1 ELSE 0 END,
    CASE WHEN DATE(NOW()) = DATE(NEW.created_at) 
         THEN NEW.commission_amount ELSE 0 END,
    CASE WHEN DATE(NOW()) = DATE(NEW.created_at) 
         THEN 1 ELSE 0 END
  FROM secondary_sales s
  WHERE s.sales_code = NEW.sales_code
  ON CONFLICT (sales_id) DO UPDATE SET
    total_earned = sales_balance.total_earned + NEW.commission_amount,
    pending_amount = sales_balance.pending_amount + NEW.commission_amount,
    total_orders = sales_balance.total_orders + 1,
    month_earned = CASE 
      WHEN DATE_TRUNC('month', NOW()) = DATE_TRUNC('month', NEW.created_at)
      THEN sales_balance.month_earned + NEW.commission_amount
      ELSE sales_balance.month_earned
    END,
    month_orders = CASE 
      WHEN DATE_TRUNC('month', NOW()) = DATE_TRUNC('month', NEW.created_at)
      THEN sales_balance.month_orders + 1
      ELSE sales_balance.month_orders
    END,
    today_earned = CASE 
      WHEN DATE(NOW()) = DATE(NEW.created_at)
      THEN sales_balance.today_earned + NEW.commission_amount
      ELSE sales_balance.today_earned
    END,
    today_orders = CASE 
      WHEN DATE(NOW()) = DATE(NEW.created_at)
      THEN sales_balance.today_orders + 1
      ELSE sales_balance.today_orders
    END,
    updated_at = NOW();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER trigger_create_reconciliation
AFTER INSERT ON orders
FOR EACH ROW EXECUTE FUNCTION create_reconciliation_record();
```

### 2. 订单确认时更新对账状态
```sql
CREATE OR REPLACE FUNCTION update_reconciliation_status()
RETURNS TRIGGER AS $$
BEGIN
  -- 当订单状态变为已确认配置时
  IF NEW.status = 'confirmed_config' AND OLD.status != 'confirmed_config' THEN
    -- 更新对账记录状态
    UPDATE sales_reconciliation
    SET 
      settlement_status = 'confirmed',
      confirmed_at = NOW()
    WHERE order_id = NEW.id;
    
    -- 更新销售余额
    UPDATE sales_balance sb
    SET 
      pending_amount = pending_amount - NEW.commission_amount,
      current_balance = current_balance + NEW.commission_amount
    FROM sales_reconciliation sr
    WHERE sr.order_id = NEW.id
      AND sr.sales_id = sb.sales_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 四、📱 前端实时展示

### 1. 销售端实时看到每笔订单的对账
```javascript
// 实时订阅对账记录
const subscribeToReconciliation = (salesCode) => {
  const channel = supabase.channel('reconciliation');
  
  channel
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'sales_reconciliation',
      filter: `sales_code=eq.${salesCode}`
    }, (payload) => {
      // 实时显示新的对账记录
      addNewReconciliation(payload.new);
      
      // 更新余额显示
      updateBalance(payload.new.balance_after);
      
      // 播放提示音
      playNotificationSound();
      
      // 显示通知
      showNotification(`新订单！佣金 +$${payload.new.commission_amount}`);
    })
    .subscribe();
};
```

### 2. 对账页面显示
```javascript
const SalesReconciliationRealtime = () => {
  const [records, setRecords] = useState([]);
  const [balance, setBalance] = useState({});
  
  // 加载实时对账记录
  const loadReconciliation = async () => {
    // 获取最近的对账记录
    const { data: recentRecords } = await supabase
      .from('sales_reconciliation')
      .select('*')
      .eq('sales_code', salesCode)
      .order('created_at', { ascending: false })
      .limit(100);
    
    // 获取余额信息
    const { data: balanceData } = await supabase
      .from('sales_balance')
      .select('*')
      .eq('sales_code', salesCode)
      .single();
    
    setRecords(recentRecords);
    setBalance(balanceData);
  };
  
  return (
    <div>
      {/* 余额卡片 */}
      <Row gutter={16}>
        <Col span={6}>
          <Card>
            <Statistic 
              title="当前余额" 
              value={balance.current_balance}
              prefix="$"
              valueStyle={{ color: '#3f8600' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic 
              title="待确认" 
              value={balance.pending_amount}
              prefix="$"
              valueStyle={{ color: '#faad14' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic 
              title="今日收入" 
              value={balance.today_earned}
              prefix="$"
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic 
              title="本月收入" 
              value={balance.month_earned}
              prefix="$"
            />
          </Card>
        </Col>
      </Row>
      
      {/* 实时对账明细 */}
      <Table
        columns={[
          { title: '时间', dataIndex: 'created_at', render: (t) => moment(t).format('MM-DD HH:mm:ss') },
          { title: '订单号', dataIndex: 'order_number' },
          { title: '客户', dataIndex: 'customer_wechat' },
          { title: '订单金额', dataIndex: 'order_amount', render: (v) => `$${v}` },
          { title: '佣金率', dataIndex: 'commission_rate', render: (v) => `${(v*100).toFixed(1)}%` },
          { title: '佣金', dataIndex: 'commission_amount', render: (v) => `+$${v}` },
          { title: '余额', dataIndex: 'balance_after', render: (v) => `$${v}` },
          { 
            title: '状态', 
            dataIndex: 'settlement_status',
            render: (status) => {
              const map = {
                'pending': { text: '待确认', color: 'orange' },
                'confirmed': { text: '已确认', color: 'blue' },
                'settled': { text: '已结算', color: 'green' },
                'paid': { text: '已支付', color: 'success' }
              };
              const info = map[status];
              return <Tag color={info.color}>{info.text}</Tag>;
            }
          }
        ]}
        dataSource={records}
        rowKey="id"
      />
    </div>
  );
};
```

---

## 五、✅ 优势总结

### 实时性：
- **每笔订单立即产生对账记录**
- **余额实时更新**
- **前端实时推送通知**

### 精确性：
- **每笔交易都有记录**
- **余额变化可追溯**
- **支持争议和调整**

### 灵活性：
- **支持日汇总报表**（daily_reconciliation_summary）
- **支持实时明细**（sales_reconciliation）
- **支持余额查询**（sales_balance）

这样设计的对账系统才是真正的实时系统，销售可以立即看到每笔订单的佣金，不需要等待！