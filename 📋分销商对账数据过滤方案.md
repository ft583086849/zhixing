# 📋 分销商对账数据过滤方案

## 🎯 推荐方案：后端API过滤

### 理由分析

#### ✅ 后端过滤优势
1. **安全性** - 防止前端绕过过滤逻辑
2. **性能** - 减少网络传输，只传输需要的数据
3. **数据库效率** - SQL层面过滤，利用索引优化
4. **统一逻辑** - 所有客户端使用相同过滤规则
5. **维护性** - 业务逻辑集中管理

#### ❌ 前端过滤缺点
1. **安全风险** - 用户可能通过开发者工具看到所有数据
2. **性能问题** - 传输无用数据，浪费带宽
3. **数据一致性** - 不同页面可能过滤逻辑不一致

## 🔧 具体实现方案

### 当前数据库结构
```sql
-- orders 表中的关键过滤字段
config_confirmed BOOLEAN DEFAULT FALSE  -- 配置是否完成（关键过滤字段）
status VARCHAR(50) DEFAULT 'pending_payment'  -- 订单状态
sales_type VARCHAR(20) NOT NULL  -- 销售类型：'primary' | 'secondary'
primary_sales_id INTEGER  -- 一级分销ID
secondary_sales_id INTEGER  -- 二级分销ID
```

### API设计建议

#### 1. 一级分销对账API
```javascript
// GET /api/sales/primary-settlement?sales_code=PS_XXX
// 后端SQL过滤
const query = `
  SELECT o.* FROM orders o
  WHERE o.primary_sales_id = ? 
    AND o.config_confirmed = true  -- 后端过滤
    AND o.status IN ('confirmed_configuration', 'completed')
  ORDER BY o.created_at DESC
`;
```

#### 2. 二级分销对账API  
```javascript
// GET /api/sales/secondary-settlement?sales_code=SS_XXX
// 后端SQL过滤
const query = `
  SELECT o.* FROM orders o
  WHERE o.secondary_sales_id = ? 
    AND o.config_confirmed = true  -- 后端过滤
    AND o.status IN ('confirmed_configuration', 'completed')
  ORDER BY o.created_at DESC
`;
```

#### 3. 统一过滤函数
```javascript
// 在API层统一过滤逻辑
function getSettlementOrders(salesId, salesType) {
  const baseQuery = `
    SELECT 
      o.*,
      CASE 
        WHEN o.sales_type = 'primary' THEN ps.wechat_name
        WHEN o.sales_type = 'secondary' THEN ss.wechat_name
      END as sales_name
    FROM orders o
    LEFT JOIN primary_sales ps ON o.primary_sales_id = ps.id
    LEFT JOIN secondary_sales ss ON o.secondary_sales_id = ss.id
    WHERE o.config_confirmed = true  -- 核心过滤条件
  `;
  
  if (salesType === 'primary') {
    return baseQuery + ` AND o.primary_sales_id = ?`;
  } else {
    return baseQuery + ` AND o.secondary_sales_id = ?`;
  }
}
```

## 📊 过滤规则定义

### 一级分销对账页面
**只显示以下订单：**
- ✅ `config_confirmed = true` （配置已确认）
- ✅ `primary_sales_id = 当前一级分销ID`
- ✅ `status IN ('confirmed_configuration', 'completed')`

### 二级分销对账页面  
**只显示以下订单：**
- ✅ `config_confirmed = true` （配置已确认）
- ✅ `secondary_sales_id = 当前二级分销ID`
- ✅ `status IN ('confirmed_configuration', 'completed')`

### 管理员页面（例外）
**显示所有订单：**
- ✅ 不过滤 `config_confirmed` 
- ✅ 管理员需要看到所有订单状态
- ✅ 可以手动操作 `config_confirmed` 状态

## 🚀 实施步骤

### 步骤1：API层修改
1. 修改 `SalesAPI.getPrimarySalesSettlement()`
2. 修改 `SalesAPI.getSecondarySalesSettlement()`
3. 在SQL查询中添加 `config_confirmed = true` 条件

### 步骤2：前端调用
```javascript
// 一级分销对账页面
const response = await SalesAPI.getPrimarySalesSettlement(salesCode);
// 返回的数据已经过滤，前端直接显示

// 二级分销对账页面  
const response = await SalesAPI.getSecondarySalesSettlement(salesCode);
// 返回的数据已经过滤，前端直接显示
```

### 步骤3：数据库索引优化
```sql
-- 为过滤字段创建组合索引
CREATE INDEX idx_orders_settlement ON orders(config_confirmed, primary_sales_id, status);
CREATE INDEX idx_orders_secondary_settlement ON orders(config_confirmed, secondary_sales_id, status);
```

## 🔍 验证方法

### API测试
```bash
# 测试一级分销对账
curl "http://localhost:5000/api/sales/primary-settlement?sales_code=PS_TEST001"

# 验证返回数据只包含 config_confirmed=true 的订单
```

### 前端验证
```javascript
// 在对账页面检查
console.log('所有订单的config_confirmed状态:', 
  orders.every(order => order.config_confirmed === true)
);
```

## 💡 最佳实践

1. **API层过滤** - 在数据源头过滤
2. **前端展示** - 直接展示API返回的数据
3. **管理员例外** - 管理员API不过滤，可看所有状态
4. **缓存优化** - 对过滤后的结果进行缓存
5. **日志记录** - 记录过滤操作，便于调试

## ⚠️ 注意事项

1. **数据一致性** - 确保所有相关API都使用相同的过滤逻辑
2. **性能监控** - 监控过滤查询的性能
3. **权限控制** - 确保分销商只能看到自己的数据
4. **测试覆盖** - 全面测试过滤逻辑的正确性

## 🎯 结论

**强烈推荐在后端API层面进行数据过滤**，这样既保证了安全性，又提高了性能，还便于维护。前端只需要负责展示已经过滤好的数据即可。